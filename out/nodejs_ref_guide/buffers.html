<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Node.js Reference Guide</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/sh.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
      }
    </style>
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
  <script src="../js/toc.js"></script>
    <script type="text/javascript">
    $(document).ready(function() {
        //$("#toc").accordion({ event: 'mouseover' }, { autoHeight: false });
    });
    </script>
    <link href="../css/style_override.css" rel="stylesheet">
  </head>

  <body>
    <!--
        <div class="topbar">
          <div class="topbar-inner">
            <div class="container-fluid">
              <a class="brand" href="#">Project name</a>
              <ul class="nav">
                <li class="active"><a href="#">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#contact">Contact</a></li>
              </ul>
              <p class="pull-right">Logged in as <a href="#">username</a></p>
            </div>
          </div>
        </div>
    -->

    <div class="container-fluid">
      <div class="sidebar">
        <div id="toc" class="well">
        <h5>Node.js Reference Guide</h5>
<div>
<ul>
<li><a class="upper" href="globals.html">Global Objects</a></li>
<li><a class="upper" href="stdio.html">Printing to Console</a></li>
<li><a class="upper" href="timers.html">Timers</a></li>
<li><a class="upper" href="modules.html">Modules</a></li>
<li><a class="upper" href="addons.html">Addons</a></li>
<li><a class="upper" href="process.html">process</a></li>
<li><a class="upper" href="util.html">util</a></li>
<li><a class="upper" href="events.html">Events</a></li>
<li><a class="upper" href="buffers.html">Buffers</a></li>
<li><a class="upper" href="streams.html">Streams</a></li>
<li><a class="upper" href="crypto.html">Cryptography and OpenSSL</a></li>
<li><a class="upper" href="tls.html">Implementing TLS & SSL</a></li>
<li><a class="upper" href="fs.html">File System</a></li>
<li><a class="upper" href="net.html">net</a></li>
<li><a class="upper" href="dgram.html">UDP / Datagram Sockets</a></li>
<li><a class="upper" href="dns.html">DNS</a></li>
<li><a class="upper" href="http.html">HTTP</a></li>
<li><a class="upper" href="https.html">HTTPS</a></li>
<li><a class="upper" href="url.html">URL</a></li>
<li><a class="upper" href="querystring.html">Query String</a></li>
<li><a class="upper" href="readline.html">Readline</a></li>
<li><a class="upper" href="repl.html">REPL</a></li>
<li><a class="upper" href="vm.html">Executing JavaScript</a></li>
<li><a class="upper" href="child_processes.html">Child Processes</a></li>
<li><a class="upper" href="assert.html">Assert</a></li>
<li><a class="upper" href="tty.html">TTY</a></li>
<li><a class="upper" href="zlib.html">Zlib</a></li>
<li><a class="upper" href="os.html">os Module</a></li>
<li><a class="upper" href="debugger.html">Debugger</a></li>
<li><a class="upper" href="cluster.html">Cluster</a></li>
<li><a class="upper" href="appendix_1.html">Appendix 1 - Third Party Modules</a></li>
</ul></div>
</div>
</div>
<div class="content"><p><div class="hero-unit"></p>

<p><a class="hiddenLink" id="buffers"></a></p>

<h2>Buffers</h2>

<p>Pure Javascript is Unicode friendly but not nice to binary data.  When dealing with TCP streams or the file system, it's necessary to handle octet streams. Node.js has several strategies for manipulating, creating, and consuming octet streams.</p>

<p>Raw data is stored in instances of the <code>Buffer</code> class. A <code>Buffer</code> is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap. A <code>Buffer</code> cannot be resized.</p>

<p>The <code>Buffer</code> object is global.</p>

<p>Converting between Buffers and Javascript string objects requires an explicit encoding method.  Here are the different string encodings;</p>

<ul>
<li><p><code>'ascii'</code>: for 7-bit ASCII data only. This encoding method is very fast, and strips the high bit if set.<br />Note that this encoding converts a <code>null</code> character (<code>'\0'</code> or <code>'\u0000'</code>) into<br /><code>0x20</code> (character code of a space). If you want to convert a <code>null</code> character<br />into <code>0x00</code>, you should use the <code>'utf8'</code> encoding.</p></li>
<li><p><code>'utf8'</code>: multi byte encoded Unicode characters.  Many web pages and other document formats use UTF-8. </p></li>
<li><p><code>'ucs2'</code>: 2-bytes, little endian encoded Unicode characters. It can encode<br />only BMP (Basic Multilingual Plane&mdash;from U+0000 to U+FFFF).</p></li>
<li><p><code>'base64'</code>: Base64 string encoding</p></li>
<li><p><code>'binary'</code>: A way of encoding raw binary data into strings by using only the first 8 bits of each character. This encoding method is deprecated and should be avoided in favor of <code>Buffer</code> objects where possible. This encoding is going to be removed in future versions of Node.js.</p></li>
<li><p><code>'hex'</code>: Encodes each byte as two hexidecimal characters.</p></li>
</ul>

<h3>Constructors</h3>

<p><h4 class="methodHeader"> <code>new Buffer(array)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>array</code>: An array of octets to allocate</ul></p>

<p>Allocates a new buffer using an <code>array</code> of octets.</p>

<p><h4 class="methodHeader"> <code>new Buffer(size)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>size</code>: The size to allocate</ul></p>

<p>Allocates a new buffer of <code>size</code> octets.</p>

<p><h4 class="methodHeader"> <code>new Buffer(str, encoding='utf8')</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>str</code>: The string to contain<li> <code>encoding</code>: The encoding to use; defaults to <code>utf8</code></li></ul></p>

<p>Allocates a new buffer containing the given <code>str</code>.</p>

<h3>Methods</h3>

<p><h4 class="methodHeader"> <code>Buffer.byteLength(string, encoding='utf8')</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>string</code>: The string to check<li> <code>encoding</code>: The encoding to use; defaults to <code>utf8</code></li></ul></p>

<p>Gives the actual byte length of a string.  This is not the same as<br /><code>String.prototype.length</code> since that returns the number of <em>characters</em> in a<br />string.</p>

<h4>Example</h4>

<pre><code>str = '\u00bd + \u00bc = \u00be';

console.log(str + ": " + str.length + " characters, " +
  Buffer.byteLength(str, 'utf8') + " bytes");

// ½ + ¼ = ¾: 9 characters, 12 bytes
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>targetBuffer</code>: The buffer to copy into<li> <code>targetStart</code>: The offset to start at for the buffer you're copying into</li><li> <code>sourceStart</code>: The offset to start at for the buffer you're copying from</li><li> <code>sourceEnd</code>: The number of bytes to read from the originating bugger; defaults to the length of the buffer</li></ul></p>

<p>Performs a copy between buffers. The source and target regions can overlap.</p>

<h4>Example</h4>

<p>Building two Buffers, then copy <code>buf1</code> from byte 16 through byte 19<br />into <code>buf2</code>, starting at the 8th byte in <code>buf2</code>:</p>

<pre><code>buf1 = new Buffer(26);
buf2 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
  buf2[i] = 33; // ASCII !
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString('ascii', 0, 25));

// prints !!!!!!!!qrst!!!!!!!!!!!!!
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.fill(value, offset=0, end=buffer.length)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>value</code>: The value to use<li> <code>offset</code>: The position to start at</li><li> <code>end</code></li></ul></p>

<p>Fills the buffer with the specified value. If the offset and end are not<br />given it will fill the entire buffer.</p>

<h4>Example</h4>

<pre><code>var b = new Buffer(50);
b.fill("h");
</code></pre>

<p><h4 class="methodHeader"> <code>Buffer.isBuffer(obj)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>obj</code>: The object to check</ul></p>

<p>Returns <code>true</code> if <code>obj</code> is a <code>Buffer</code>.</p>

<p><h4 class="methodHeader"> <code>buffer.readDoubleBE(offset, noAssert=false)</code> / <code>buffer.readDoubleLE(offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>offset</code>: The starting position<li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset </li></ul></p>

<p>Reads a 64 bit double from the buffer at the specified offset with<br />specified endian format--either "BE" for "big endian" or "LE" for "little endian."</p>

<p>"Skipping the validation" means that <code>offset</code> may be beyond the end of the buffer. This is typically Not Good.</p>

<h4>Example</h4>

<pre><code>var buf = new Buffer(8);

buf[0] = 0x55;
buf[1] = 0x55;
buf[2] = 0x55;
buf[3] = 0x55;
buf[4] = 0x55;
buf[5] = 0x55;
buf[6] = 0xd5;
buf[7] = 0x3f;

console.log(buf.readDoubleLE(0));

// prints 0.3333333333333333
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.readFloatBE(offset, noAssert=false)</code> / <code>buffer.readFloatLE(offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>offset</code>: The starting position<li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset </li></ul></p>

<p>Reads a 32 bit float from the buffer at the specified offset with<br />specified endian format--either "BE" for "big endian" or "LE" for "little endian."</p>

<p>"Skipping the validation" means that <code>offset</code> may be beyond the end of the buffer. This is typically Not Good.</p>

<h4>Example</h4>

<pre><code>var buf = new Buffer(4);

buf[0] = 0x00;
buf[1] = 0x00;
buf[2] = 0x80;
buf[3] = 0x3f;

console.log(buf.readFloatLE(0));

// prints 0x01
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.readInt8(offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>offset</code>: The starting position<li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset</li></ul></p>

<p>Reads a signed 8 bit integer from the buffer at the specified offset.</p>

<p>"Skipping the validation" means that <code>offset</code> may be beyond the end of the buffer. This is typically Not Good.</p>

<p>Works as <code>buffer.readUInt8()</code>, except buffer contents are treated as two's<br />complement signed values.</p>

<p><h4 class="methodHeader"> <code>buffer.readInt16BE(offset, noAssert=false)</code> / <code>buffer.readInt16LE(offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>offset</code>: The starting position<li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset </li></ul></p>

<p>Reads a signed 16 bit integer from the buffer at the specified offset with<br />specified endian format--either "BE" for "big endian" or "LE" for "little endian."</p>

<p>"Skipping the validation" means that <code>offset</code> may be beyond the end of the buffer. This is typically Not Good.</p>

<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as a two's<br />complement signed values.</p>

<p><h4 class="methodHeader"> <code>buffer.readInt32BE(offset, noAssert=false)</code> / <code>buffer.readInt32LE(offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>offset</code>: The starting position<li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset </li></ul></p>

<p>Reads a signed 32 bit integer from the buffer at the specified offset with<br />specified endian format--either "BE" for "big endian" or "LE" for "little endian."</p>

<p>"Skipping the validation" means that <code>offset</code> may be beyond the end of the buffer. This is typically Not Good.</p>

<p>Works as <code>buffer.readUInt32*()</code>, except buffer contents are treated as a two's<br />complement signed values.</p>

<p><h4 class="methodHeader"> <code>buffer.readUInt8(offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>offset</code>: The starting position<li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset</li></ul></p>

<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.</p>

<p>"Skipping the validation" means that <code>offset</code> may be beyond the end of the buffer. This is typically Not Good.</p>

<h4>Example</h4>

<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

for (ii = 0; ii &lt; buf.length; ii++) {
  console.log(buf.readUInt8(ii));
}

// prints the following
// 0x3
// 0x4
// 0x23
// 0x42
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.readUInt16BE(offset, noAssert=false) / buffer.readUInt16LE(offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>offset</code>: The starting position<li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset</li></ul></p>

<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with<br />specified endian format--either "BE" for "big endian" or "LE" for "little endian."</p>

<p>"Skipping the validation" means that <code>offset</code> may be beyond the end of the buffer. This is typically Not Good.</p>

<h4>Example</h4>

<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt16BE(0));
console.log(buf.readUInt16LE(0));
console.log(buf.readUInt16BE(1));
console.log(buf.readUInt16LE(1));
console.log(buf.readUInt16BE(2));
console.log(buf.readUInt16LE(2));

// prints the following
// 0x0304
// 0x0403
// 0x0423
// 0x2304
// 0x2342
// 0x4223
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.readUInt32BE(offset, noAssert=false)</code> / <code>buffer.readUInt32LE(offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>offset</code>: The starting position<li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset</li></ul></p>

<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with<br />specified endian format--either "BE" for "big endian" or "LE" for "little endian."</p>

<p>"Skipping the validation" means that <code>offset</code> may be beyond the end of the buffer. This is typically Not Good.</p>

<h4>Example</h4>

<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt32BE(0));
console.log(buf.readUInt32LE(0));

// 0x03042342
// 0x42230403
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.slice(start, end=buffer.length)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>start</code>: The offset to start from<li> <code>end</code>: The position of the last byte to slice; defaults to the length of the buffer</li></ul></p>

<p>Returns a new buffer that references the same memory as the old, but offset and cropped by the <code>start</code> and <code>end</code> indexes.</p>

<p><strong>Note</strong>: Modifying the new buffer slice modifies memory in the original buffer!</p>

<h4>Example</h4>

<p>Building a <code>Buffer</code> with the ASCII alphabet, taking a slice, then modifying one byte from the original <code>Buffer</code>:</p>

<pre><code>var buf1 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

var buf2 = buf1.slice(0, 3);
console.log(buf2.toString('ascii', 0, buf2.length));
buf1[0] = 33;
console.log(buf2.toString('ascii', 0, buf2.length));

// prints the following:
// abc
// !bc
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.toString(encoding, start=0, end=buffer.length)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>encoding</code>: The encoding to use; defaults to <code>utf8</code><li> <code>start</code>: The starting byte offset; defaults to <code>0</code></li><li> <code>end</code>: The number of bytes to write; defaults to the length of the buffer</li></ul></p>

<p>Decodes and returns a string from buffer data encoded with <code>encoding</code><br />beginning at <code>start</code> and ending at <code>end</code>.</p>

<p>For more information, see the <code>buffer.write()</code> example.</p>

<p><h4 class="methodHeader"> <code>buffer.write(string, offset=0, length=buffer.length-offset, encoding='utf8')</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>string</code>: The string to write<li> <code>offset</code>: The starting byte offset; defaults to <code>0</code></li><li> <code>length</code>: The number of bytes to write; defaults to the length of the buffer (minus any offset)</li><li> <code>encoding</code>: The encoding to use; defaults to <code>utf8</code></li></ul></p>

<p>Writes a <code>string</code> to the buffer at <code>offset</code> using the given encoding. <code>length</code> is the number of bytes to write. Returns number of octets written. If <code>buffer</code> does not contain enough space to fit the entire string, it instead writes a partial amount of the string. The method doesn't write partial characters.</p>

<p>The number of characters written (which may be different than the number of<br />bytes written) is set in <code>Buffer._charsWritten</code> and will be overwritten the<br />next time <code>buf.write()</code> is called.</p>

<h4>Example</h4>

<p>Writing a utf8 string into a buffer, then printing it:</p>

<pre><code>buf = new Buffer(256);
len = buf.write('\u00bd + \u00bc = \u00be', 0);
console.log(len + " bytes: " + buf.toString('utf8', 0, len));
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.writeDoubleBE(value, offset, noAssert=false)</code> / <code>buffer.writeDoubleLE(value, offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>value</code>: The content to write<li> <code>offset</code>: The starting position</li><li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset </li></ul></p>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian<br />format--either "BE" for "big endian" or "LE" for "little endian." Note that <code>value</code> must be a valid 64 bit double.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means<br />that <code>value</code> may be too large for the specific function and <code>offset</code> may be<br />beyond the end of the buffer leading to the values being silently dropped. This<br />shouldn't be used unless you are certain of correctness.</p>

<h4>Example</h4>

<pre><code>var buf = new Buffer(8);
buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

console.log(buf);

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

console.log(buf);

// prints the following
// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.writeFloatBE(value, offset, noAssert=false)</code> / <code>buffer.writeFloatLE(value, offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>value</code>: The content to write<li> <code>offset</code>: The starting position</li><li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset</li></ul></p>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian<br />format--either "BE" for "big endian" or "LE" for "little endian." Note that <code>value</code> must be a valid 32 bit float.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means<br />that <code>value</code> may be too large for the specific function and <code>offset</code> may be<br />beyond the end of the buffer leading to the values being silently dropped. This<br />shouldn't be used unless you are certain of correctness.</p>

<h4>Example</h4>

<pre><code>var buf = new Buffer(4);
buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);

// &lt;Buffer 4f 4a fe bb&gt;
// &lt;Buffer bb fe 4a 4f&gt;
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.writeInt8(value, offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>value</code>: The content to write<li> <code>offset</code>: The starting position</li><li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset </li></ul></p>

<p>Writes <code>value</code> to the buffer at the specified offset. Note that <code>value</code> must be a valid signed 8 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means<br />that <code>value</code> may be too large for the specific function and <code>offset</code> may be<br />beyond the end of the buffer leading to the values being silently dropped. This<br />shouldn't be used unless you are certain of correctness.</p>

<p>Works as <code>buffer.writeUInt8()</code>, except value is written out as a two's complement<br />signed integer into <code>buffer</code>.</p>

<p><h4 class="methodHeader"> <code>buffer.writeInt16BE(value, offset, noAssert=false)</code> / <code>buffer.writeInt16LE(value, offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>value</code>: The content to write<li> <code>offset</code>: The starting position</li><li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset </li></ul></p>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian<br />format--either "BE" for "big endian" or "LE" for "little endian." Note that <code>value</code> must be a valid signed 16 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means<br />that <code>value</code> may be too large for the specific function and <code>offset</code> may be<br />beyond the end of the buffer leading to the values being silently dropped. This<br />shouldn't be used unless you are certain of correctness.</p>

<p>Works as <code>buffer.writeUInt16*()</code>, except value is written out as a two's<br />complement signed integer into <code>buffer</code>.</p>

<p><h4 class="methodHeader"> <code>buffer.writeInt32BE(value, offset, noAssert=false)</code> / <code>buffer.writeInt32LE(value, offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>value</code>: The content to write<li> <code>offset</code>: The starting position</li><li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset </li></ul></p>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian<br />format--either "BE" for "big endian" or "LE" for "little endian." Note that <code>value</code> must be a valid signed 32 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means<br />that <code>value</code> may be too large for the specific function and <code>offset</code> may be<br />beyond the end of the buffer leading to the values being silently dropped. This<br />shouldn't be used unless you are certain of correctness.</p>

<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two's<br />complement signed integer into <code>buffer</code>.</p>

<p><h4 class="methodHeader"> <code>buffer.writeUInt8(value, offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>value</code>: The content to write<li> <code>offset</code>: The starting position</li><li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset </li></ul></p>

<p>Writes <code>value</code> to the buffer at the specified offset. Note that <code>value</code> must be a valid unsigned 8 bit integer.</p>

<p>Set <code>noAssert</code> to <code>true</code> to skip validation of <code>value</code> and <code>offset</code>. This means<br />that <code>value</code> may be too large for the specific function and <code>offset</code> may be<br />beyond the end of the buffer leading to the values being silently dropped. This<br />shouldn't be used unless you are certain of correctness.</p>

<h4>Example</h4>

<pre><code>var buf = new Buffer(4);
buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);

// prints &lt;Buffer 03 04 23 42&gt;
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.writeUInt16BE(value, offset, noAssert=false)</code> / <code>buffer.writeUInt16LE(value, offset, noAssert=false)</code> </h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>value</code>: The content to write<li> <code>offset</code>: The starting position</li><li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset </li></ul></p>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian<br />format--either "BE" for "big endian" or "LE" for "little endian." Note that <code>value</code> must be a valid unsigned 16 bit integer.</p>

<p>Set <code>noAssert</code> to <code>true</code> to skip validation of <code>value</code> and <code>offset</code>. This means<br />that <code>value</code> may be too large for the specific function and <code>offset</code> may be<br />beyond the end of the buffer leading to the values being silently dropped. This<br />shouldn't be used unless you are certain of correctness.</p>

<h4>Example</h4>

<pre><code>var buf = new Buffer(4);
buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);

// prints the following
// &lt;Buffer de ad be ef&gt;
// &lt;Buffer ad de ef be&gt;
</code></pre>

<p><h4 class="methodHeader"> <code>buffer.writeUInt32BE(value, offset, noAssert=false)</code> / <code>buffer.writeUInt32LE(value, offset, noAssert=false)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>value</code>: The content to write<li> <code>offset</code>: The starting position</li><li> <code>noAssert</code>: If <code>true</code></li><li> skips the validation of the offset </li></ul></p>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian<br />format--either "BE" for "big endian" or "LE" for "little endian." Note that <code>value</code> must be a valid unsigned 32 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means<br />that <code>value</code> may be too large for the specific function and <code>offset</code> may be<br />beyond the end of the buffer leading to the values being silently dropped. This<br />shouldn't be used unless you are certain of correctness.</p>

<h4>Example</h4>

<pre><code>var buf = new Buffer(4);
buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);

// prints the following
// &lt;Buffer fe ed fa ce&gt;
// &lt;Buffer ce fa ed fe&gt;
</code></pre>

<h3>Properties</h3>

<p><h4 class="propertyHeader"> <code>buffer[index]</code></h4></p>

<p>Get and set the octet at <code>index</code>. The values refer to individual bytes,<br />so the legal range is between <code>0x00</code> and <code>0xFF</code> hex or <code>0</code> and <code>255</code>.</p>

<h4>Example</h4>

<p>Copying an ASCII string into a buffer, one byte at a time:</p>

<pre><code>str = "node.js";
buf = new Buffer(str.length);

for (var i = 0; i &lt; str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf);

// prints node.js
</code></pre>

<p><h4 class="propertyHeader"> <code>buffer.length</code></h4></p>

<p>The size of the buffer in bytes.  Note that this is not necessarily the size of the contents. <code>length</code> refers to the amount of memory allocated for the buffer object.  It does not change when the contents of the buffer are changed.</p>

<h4>Example</h4>

<pre><code>buf = new Buffer(1234);

console.log(buf.length);
buf.write("some string", "ascii", 0);
console.log(buf.length);

// 1234
// 1234
</code></pre>

<p>@param INSPECT_MAX_BYTES</p>

<p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can be overriden by user modules.</div></p></div>
</div>
<footer>
    <p>&nbsp;</p>
</footer>
        
<script type="text/javascript" src="../js/sh_main.js"></script>
<script type="text/javascript" src="../js/sh_javascript.min.js"></script>
</div>
    </div>

  </body>
</html>