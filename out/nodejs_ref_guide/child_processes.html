<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Node.js Reference Guide</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/sh.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
      }
    </style>
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
  <script src="../js/toc.js"></script>
    <script type="text/javascript">
    $(document).ready(function() {
        //$("#toc").accordion({ event: 'mouseover' }, { autoHeight: false });
    });
    </script>
    <link href="../css/style_override.css" rel="stylesheet">
  </head>

  <body>
    <!--
        <div class="topbar">
          <div class="topbar-inner">
            <div class="container-fluid">
              <a class="brand" href="#">Project name</a>
              <ul class="nav">
                <li class="active"><a href="#">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#contact">Contact</a></li>
              </ul>
              <p class="pull-right">Logged in as <a href="#">username</a></p>
            </div>
          </div>
        </div>
    -->

    <div class="container-fluid">
      <div class="sidebar">
        <div id="toc" class="well">
        <h5>Node.js Reference Guide</h5>
<div>
<ul>
<li><a class="upper" href="globals.html">Global Objects</a></li>
<li><a class="upper" href="stdio.html">Printing to Console</a></li>
<li><a class="upper" href="timers.html">Timers</a></li>
<li><a class="upper" href="modules.html">Modules</a></li>
<li><a class="upper" href="addons.html">Addons</a></li>
<li><a class="upper" href="process.html">process</a></li>
<li><a class="upper" href="util.html">util</a></li>
<li><a class="upper" href="events.html">Events</a></li>
<li><a class="upper" href="buffers.html">Buffers</a></li>
<li><a class="upper" href="streams.html">Streams</a></li>
<li><a class="upper" href="crypto.html">Cryptography and OpenSSL</a></li>
<li><a class="upper" href="tls.html">Implementing TLS & SSL</a></li>
<li><a class="upper" href="fs.html">Working with the File System</a></li>
<li><a class="upper" href="net.html">net</a></li>
<li><a class="upper" href="dgram.html">UDP and Datagram Sockets</a></li>
<li><a class="upper" href="dns.html">DNS</a></li>
<li><a class="upper" href="http.html">HTTP</a></li>
<li><a class="upper" href="https.html">HTTPS</a></li>
<li><a class="upper" href="url.html">URL</a></li>
<li><a class="upper" href="querystring.html">Query String</a></li>
<li><a class="upper" href="readline.html">Readline</a></li>
<li><a class="upper" href="repl.html">REPL</a></li>
<li><a class="upper" href="vm.html">Executing JavaScript</a></li>
<li><a class="upper" href="child_processes.html">Child Processes</a></li>
<li><a class="upper" href="assert.html">Assert</a></li>
<li><a class="upper" href="tty.html">TTY</a></li>
<li><a class="upper" href="zlib.html">Zipping with zlib</a></li>
<li><a class="upper" href="os.html">Accessing the OS</a></li>
<li><a class="upper" href="debugger.html">Debugging Node.js</a></li>
<li><a class="upper" href="cluster.html">Clusters</a></li>
<li><a class="upper" href="appendix_1.html">A1: Third Party Modules</a></li>
</ul></div>
</div>
</div>
<div class="content"><p><div class="hero-unit"></p>

<p><a class="hiddenLink" id="child-processes"></a></p>

<h2>Child Processes</h2>

<p>Node.js provides a tri-directional <code>popen(3)</code> facility through the <code>ChildProcess</code> class.</p>

<p>It is possible to stream data through the child's <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> in a fully non-blocking way.</p>

<p>To create a child process, use <code>require('child_process').spawn()</code> in your code.</p>

<p>Child processes always have three streams associated with them. They are:</p>

<ul>
<li><code>child.stdin</code></li>
<li><code>child.stdout</code></li>
<li><code>child.stderr</code></li>
</ul>

<p><code>ChildProcess</code> is also an <code>EventEmitter</code>.</p>

<h3>Events</h3>

<p><h4 class="eventHeader"> <code>'exit'</code></h4><div class="listenerParam"><h5>Listener Parameters</h5><ul><li><code>function(code<div class="listenerParamParam"><h6>Parameters</h6><ul><li> signal)</code>: The function to execute once the event fires</li><li> <code>code</code>: The final exit code of the process (otherwise</li><li> <code>null</code>)</li><li> <code>signal</code>: The string name of the signal (otherwise</li><li> <code>null</code>)</li></ul></li></ul></p>

<p>This event is emitted after the child process ends.</p>

<p>For more information, see <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/wait.2.html">waitpid(2)</a>.</p>

<h3>Properties</h3>

<p><h4 class="propertyHeader"> <code>child.stdin</code></h4></p>

<p>A <code>Writable Stream</code> that represents the child process's <code>stdin</code>. Closing this stream via <code>end()</code> often causes the child process to terminate.</p>

<p><h4 class="propertyHeader"> <code>child.stdout</code></h4></p>

<p>A <code>Readable Stream</code> that represents the child process's <code>stdout</code>.</p>

<p><h4 class="propertyHeader"> <code>child.stderr</code></h4></p>

<p>A <code>Readable Stream</code> that represents the child process's <code>stderr</code>.</p>

<p><h4 class="propertyHeader"> <code>child.pid</code></h4></p>

<p>The PID of the child process.</p>

<h4>Example</h4>

<pre><code>var spawn = require('child_process').spawn,
    grep  = spawn('grep', ['ssh']);

console.log('Spawned child pid: ' + grep.pid);
grep.stdin.end();
</code></pre>

<p><h4 class="methodHeader"> <code>child_process.spawn(command, args=[], [options])</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>command</code>: The command to use<li> <code>args</code>: The command line arguments to pass</li><li> <code>[options]</code>: Any additional options you want to transfer</li></ul></p>

<p>Launches a new process with the given <code>command</code>, with  command line arguments in <code>args</code>.</p>

<p><code>optiones</code> specifies additional options, which default to:</p>

<pre><code>{ cwd: undefined,
  env: process.env,
  setsid: false
}
</code></pre>

<p>They mean:</p>

<ul>
<li><code>cwd</code>: specifies the working directory from which the process is spawned</li>
<li><code>env</code>: specifies environment variables that will be visible to the new process* <code>setsid</code>: if <code>true</code>, causes the subprocess to be run in a new session</li>
</ul>

<h4>Example</h4>

<p>Running <code>ls -lh /usr</code>, capturing <code>stdout</code>, <code>stderr</code>, and the exit code:</p>

<pre><code>var util  = require('util'),
    spawn = require('child_process').spawn,
    ls    = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', function (data) {
  console.log('stdout: ' + data);
});

ls.stderr.on('data', function (data) {
  console.log('stderr: ' + data);
});

ls.on('exit', function (code) {
  console.log('child process exited with code ' + code);
});
</code></pre>

<p>A very elaborate way to run <code>'ps ax | grep ssh'</code>:</p>

<pre><code>var util  = require('util'),
    spawn = require('child_process').spawn,
    ps    = spawn('ps', ['ax']),
    grep  = spawn('grep', ['ssh']);

ps.stdout.on('data', function (data) {
  grep.stdin.write(data);
});

ps.stderr.on('data', function (data) {
  console.log('ps stderr: ' + data);
});

ps.on('exit', function (code) {
  if (code !== 0) {
    console.log('ps process exited with code ' + code);
  }
  grep.stdin.end();
});

grep.stdout.on('data', function (data) {
  console.log(data);
});

grep.stderr.on('data', function (data) {
  console.log('grep stderr: ' + data);
});

grep.on('exit', function (code) {
  if (code !== 0) {
    console.log('grep process exited with code ' + code);
  }
});
</code></pre>

<p>Checking for failed <code>exec</code>:</p>

<pre><code>var spawn = require('child_process').spawn,
    child = spawn('bad_command');

child.stderr.setEncoding('utf8');
child.stderr.on('data', function (data) {
  if (/^execvp\(\)/.test(data)) {
    console.log('Failed to start child process.');
  }
});
</code></pre>

<p>Note that if <code>spawn</code>receives an empty options object, it spawns the process with an empty environment rather than using <code>process.env</code>. This due to backwards compatibility issues with a deprecated API.</p>

<p>There is also a deprecated option called <code>customFds</code> which allows one to specify<br />specific file descriptors for the stdio of the child process. This API was<br />not portable to all platforms and therefore removed. With <code>customFds</code> it was possible to hook up the new process' [stdin, stdout, stderr] to existing stream ; <code>-1</code> meant that a new stream should be created. Use at your own risk.</p>

<p>There are also several internal options. In particular <code>stdinStream</code>, <code>stdoutStream</code>, <code>stderrStream</code>. They are for INTERNAL USE ONLY. As with all undocumented APIs in Node, they shouldn't be used.</p>

<p>For more information, see also <a href="#child_process.exec"><code>child_process.exec()</code></a>.</p>

<p><h4 class="methodHeader"> <code>child_process.exec(command, [options], callback(error, stdout, stderr))</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>command</code>: The command to run<li> <code>[options]</code>: The options to use</li><li> <code>callback(error</li><li> stdout</li><li> stderr)</code>: The function to run after the method completes; <code>error</code> is the standard <code>Error</code> object</li><li> except <code>err.code</code> is the exit code of the child process</li><li> and <code>err.signal</code> is set to the signal that terminated the process; <code>stdout</code> is the stdout stream and <code>stderr</code> is the stderr stream</li></ul></p>

<p>Runs a command in a shell and buffers the output.</p>

<p>There is a second optional argument to specify several options. The default options are:</p>

<pre><code>{ encoding: 'utf8',
  timeout: 0,
  maxBuffer: 200*1024,
  killSignal: 'SIGTERM',
  cwd: null,
  env: null }
</code></pre>

<p>If <code>timeout</code> is greater than <code>0</code>, then it will kill the child process if it runs longer than <code>timeout</code> milliseconds. The child process is killed with <code>killSignal</code>. <code>maxBuffer</code> specifies the largest amount of data allowed on stdout or stderr; if this value is exceeded then the child process is killed.</p>

<h4>Example</h4>

<pre><code>var util = require('util'),
    exec = require('child_process').exec,
    child;

child = exec('cat *.js bad_file | wc -l',
  function (error, stdout, stderr) {
    console.log('stdout: ' + stdout);
    console.log('stderr: ' + stderr);
    if (error !== null) {
      console.log('exec error: ' + error);
    }
});
</code></pre>

<p><h4 class="methodHeader"> <code>child_process.execFile(file, args, options,</code>callback(error, stdout, stderr))<code></h4><div class="methodParam"><h5>Parameters</h5><ul><li></code>file<code>: The file with the commands to run<li></code>args<code>: The command line arguments to pass</li><li></code>[options]<code>: Any additional options you want to transfer</li><li></code>callback(error</li><li> stdout</li><li> stderr)<code>: The function to run after the method completes;</code>error<code>is the standard</code>Error<code>object</li><li> except</code>err.code<code>is the exit code of the child process</li><li> and</code>err.signal<code>is set to the signal that terminated the process;</code>stdout<code>is the stdout stream and</code>stderr` is the stderr stream</li></ul></p>

<p>This is similar to <code>child_process.exec()</code> except it does not execute a<br />subshell but rather the specified file directly. This makes it slightly<br />leaner than <code>child_process.exec</code>. It has the same options and callback.</p>

<p><h4 class="methodHeader"> <code>child_process.fork(modulePath, arguments, options)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>modulePath</code>: The location of the module<li> <code>arguments</code>: Any starting arguments to use</li><li> <code>options</code>: Any additional options to pass</li></ul></p>

<p>This is a special case of the <code>spawn()</code> functionality for spawning Node.js processes. In addition to having all the methods in a normal ChildProcess instance, the returned object has a communication channel built-in. The channel is written with <code>child.send(message, [sendHandle])</code>, and messages are recieved by a <code>'message'</code> event on the child.</p>

<p>By default the spawned Node.js process will have the stdin, stdout, stderr associated with the parent's.</p>

<p>These child Nodes are still whole new instances of V8. Assume at least 30ms startup and 10mb memory for each new Node. That is, you cannot create many thousands of them.</p>

<h4>Example</h4>

<pre><code>var cp = require('child_process');

var n = cp.fork(__dirname + '/sub.js');

n.on('message', function(m) {
  console.log('PARENT got message:', m);
});

n.send({ hello: 'world' });
</code></pre>

<p>The child script, <code>'sub.js'</code>, might look like this:</p>

<pre><code>process.on('message', function(m) {
  console.log('CHILD got message:', m);
});

process.send({ foo: 'bar' });
</code></pre>

<p>In the child the <code>process</code> object will have a <code>send()</code> method, and <code>process</code>  emits objects each time it receives a message on its channel.</p>

<p>The <code>sendHandle</code> option to <code>child.send()</code> is for sending a handle object to another process. The child receives the handle as as second argument to the <code>message</code> event. Here is an example of sending a handle:</p>

<pre><code>var server = require('net').createServer();
var child = require('child_process').fork(__dirname + '/child.js');
// Open up the server object and send the handle.
server.listen(1337, function() {
  child.send({ server: true }, server._handle);
});
</code></pre>

<p>Here's an example of receiving the server handle and sharing it between processes:</p>

<pre><code>process.on('message', function(m, serverHandle) {
  if (serverHandle) {
    var server = require('net').createServer();
    server.listen(serverHandle);
  }
});
</code></pre>

<p><h4 class="methodHeader"> <code>child.kill(signal='SIGTERM')</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>signal</code>: The kill signal to send</ul></p>

<p>Send a signal to the child process. See <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/signal.7.html"><code>signal(7)</code></a> for a list of available signals.</p>

<p>Note that while the function is called <code>kill</code>, the signal delivered to the child process may not actually kill it.  <code>kill</code> really just sends a signal to a process.</p>

<p>For more information, see <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/kill.2.html"><code>kill(2)</code></a>.</p>

<h4>Example</h4>

<pre><code>var spawn = require('child_process').spawn,
    grep  = spawn('grep', ['ssh']);

grep.on('exit', function (code, signal) {
  console.log('child process terminated due to receipt of signal '+signal);
});

// send SIGHUP to process
grep.kill('SIGHUP');</div&gt;
</code></pre></div>
</div>
<footer>
    <p>&nbsp;</p>
</footer>
        
<script type="text/javascript" src="../js/sh_main.js"></script>
<script type="text/javascript" src="../js/sh_javascript.min.js"></script>
</div>
    </div>

  </body>
</html>