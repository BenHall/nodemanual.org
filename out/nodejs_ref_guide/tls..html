<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Node.js Reference Guide</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/sh.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
      }
    </style>
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
  <script src="../js/toc.js"></script>
    <script type="text/javascript">
    $(document).ready(function() {
        //$("#toc").accordion({ event: 'mouseover' }, { autoHeight: false });
    });
    </script>
    <link href="../css/style_override.css" rel="stylesheet">
  </head>

  <body>
    <!--
        <div class="topbar">
          <div class="topbar-inner">
            <div class="container-fluid">
              <a class="brand" href="#">Project name</a>
              <ul class="nav">
                <li class="active"><a href="#">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#contact">Contact</a></li>
              </ul>
              <p class="pull-right">Logged in as <a href="#">username</a></p>
            </div>
          </div>
        </div>
    -->

    <div class="container-fluid">
      <div class="sidebar">
        <div id="toc" class="well">
        <h5>Node.js Reference Guide</h5>
<div>
<ul>
<li><a class="upper" href="synopsis.html">Synopsis</a></li>
<li><a class="upper" href="globals.html">Global Objects</a></li>
<li><a class="upper" href="stdio.html">console</a></li>
<li><a class="upper" href="timers.html">Timers</a></li>
<li><a class="upper" href="modules.html">Modules</a></li>
<li><a class="upper" href="addons.html">Addons</a></li>
<li><a class="upper" href="process.html">process</a></li>
<li><a class="upper" href="util.html">util</a></li>
<li><a class="upper" href="events.html">Events</a></li>
<li><a class="upper" href="buffers.html">Buffers</a></li>
<li><a class="upper" href="streams.html">Streams</a></li>
<li><a class="upper" href="crypto.html">Crypto</a></li>
<li><a class="upper" href="tls.html">TLS (SSL)</a></li>
<li><a class="upper" href="fs.html">File System</a></li>
<li><a class="upper" href="net.html">net</a></li>
<li><a class="upper" href="dgram.html">UDP / Datagram Sockets</a></li>
<li><a class="upper" href="dns.html">DNS</a></li>
<li><a class="upper" href="http.html">HTTP</a></li>
<li><a class="upper" href="https.html">HTTPS</a></li>
<li><a class="upper" href="url.html">URL</a></li>
<li><a class="upper" href="querystring.html">Query String</a></li>
<li><a class="upper" href="readline.html">Readline</a></li>
<li><a class="upper" href="repl.html">REPL</a></li>
<li><a class="upper" href="vm.html">Executing JavaScript</a></li>
<li><a class="upper" href="child_processes.html">Child Processes</a></li>
<li><a class="upper" href="assert.html">Assert</a></li>
<li><a class="upper" href="tty.html">TTY</a></li>
<li><a class="upper" href="zlib.html">Zlib</a></li>
<li><a class="upper" href="os.html">os Module</a></li>
<li><a class="upper" href="debugger.html">Debugger</a></li>
<li><a class="upper" href="cluster.html">Cluster</a></li>
<li><a class="upper" href="appendix_1.html">Appendix 1 - Third Party Modules</a></li>
</ul></div>
</div>
</div>
<div class="content"><p><div class="hero-unit"></p>

<p><a class="hiddenLink" id="tls-ssl"></a></p>

<h2>TLS (SSL)</h2>

<p>Use <code>require('tls')</code> to access this module.</p>

<p>The <code>tls</code> module uses OpenSSL to provide Transport Layer Security and/or<br />Secure Socket Layer: encrypted stream communication.</p>

<p>TLS/SSL is a public/private key infrastructure. Each client and each<br />server must have a private key. A private key is created like this</p>

<pre><code>openssl genrsa -out ryans-key.pem 1024
</code></pre>

<p>All severs and some clients need to have a certificate. Certificates are public<br />keys signed by a Certificate Authority or self-signed. The first step to<br />getting a certificate is to create a "Certificate Signing Request" (CSR)<br />file. This is done with:</p>

<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem
</code></pre>

<p>To create a self-signed certificate with the CSR, do this:</p>

<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem
</code></pre>

<p>Alternatively you can send the CSR to a Certificate Authority for signing.</p>

<p>(TODO: docs on creating a CA, for now interested users should just look at<br /><code>test/fixtures/keys/Makefile</code> in the Node source code)</p>

<h4>tls.createServer(options, [secureConnectionListener])</h4>

<p>Creates a new <a href="#tls.Server">tls.Server</a>.<br />The <code>connectionListener</code> argument is automatically set as a listener for the<br /><a href="#event_secureConnection_">secureConnection</a> event.<br />The <code>options</code> object has these possibilities:</p>

<ul>
<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in<br />PEM format. (Required)</p></li>
<li><p><code>passphrase</code>: A string of passphrase for the private key.</p></li>
<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the server in<br />PEM format. (Required)</p></li>
<li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. If this is<br />omitted several well known "root" CAs will be used, like VeriSign.<br />These are used to authorize connections.</p></li>
<li><p><code>requestCert</code>: If <code>true</code> the server will request a certificate from<br />clients that connect and attempt to verify that certificate. Default:<br /><code>false</code>.</p></li>
<li><p><code>rejectUnauthorized</code>: If <code>true</code> the server will reject any connection<br />which is not authorized with the list of supplied CAs. This option only<br />has an effect if <code>requestCert</code> is <code>true</code>. Default: <code>false</code>.</p></li>
<li><p><code>NPNProtocols</code>: An array or <code>Buffer</code> of possible NPN protocols. (Protocols<br />should be ordered by their priority).</p></li>
<li><p><code>SNICallback</code>: A function that will be called if client supports SNI TLS<br />extension. Only one argument will be passed to it: <code>servername</code>. And<br /><code>SNICallback</code> should return SecureContext instance.<br />(You can use <code>crypto.createCredentials(...).context</code> to get proper<br />SecureContext). If <code>SNICallback</code> wasn't provided - default callback with<br />high-level API will be used (see below).</p></li>
<li><p><code>sessionIdContext</code>: A string containing a opaque identifier for session<br />resumption. If <code>requestCert</code> is <code>true</code>, the default is MD5 hash value<br />generated from command-line. Otherwise, the default is not provided.</p></li>
</ul>

<p>Here is a simple example echo server:</p>

<pre><code>var tls = require('tls');
var fs = require('fs');

var options = {
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem'),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,

  // This is necessary only if the client uses the self-signed certificate.
  ca: [ fs.readFileSync('client-cert.pem') ]
};

var server = tls.createServer(options, function(cleartextStream) {
  console.log('server connected',
              cleartextStream.authorized ? 'authorized' : 'unauthorized');
  cleartextStream.write("welcome!\n");
  cleartextStream.setEncoding('utf8');
  cleartextStream.pipe(cleartextStream);
});
server.listen(8000, function() {
  console.log('server bound');
});
</code></pre>

<p>You can test this server by connecting to it with <code>openssl s_client</code>:</p>

<pre><code>openssl s_client -connect 127.0.0.1:8000
</code></pre>

<h4>tls.connect(port, [host], [options], [secureConnectListener])</h4>

<p>Creates a new client connection to the given <code>port</code> and <code>host</code>. (If <code>host</code><br />defaults to <code>localhost</code>.) <code>options</code> should be an object which specifies</p>

<ul>
<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the client in<br />PEM format.</p></li>
<li><p><code>passphrase</code>: A string of passphrase for the private key.</p></li>
<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the client in<br />PEM format.</p></li>
<li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. If this is<br />omitted several well known "root" CAs will be used, like VeriSign.<br />These are used to authorize connections.</p></li>
<li><p><code>NPNProtocols</code>: An array of string or <code>Buffer</code> containing supported NPN<br />protocols. <code>Buffer</code> should have following format: <code>0x05hello0x05world</code>,<br />where first byte is next protocol name's length. (Passing array should<br />usually be much simplier: <code>['hello', 'world']</code>.)</p></li>
<li><p><code>servername</code>: Servername for SNI (Server Name Indication) TLS extension.</p></li>
</ul>

<p>The <code>secureConnectListener</code> parameter will be added as a listener for the<br /><a href="#event_secureConnect_">'secureConnect'</a> event.</p>

<p><code>tls.connect()</code> returns a <a href="#tls.CleartextStream">CleartextStream</a> object.</p>

<p>Here is an example of a client of echo server as described previously:</p>

<pre><code>var tls = require('tls');
var fs = require('fs');

var options = {
  // These are necessary only if using the client certificate authentication
  key: fs.readFileSync('client-key.pem'),
  cert: fs.readFileSync('client-cert.pem'),

  // This is necessary only if the server uses the self-signed certificate
  ca: [ fs.readFileSync('server-cert.pem') ]
};

var cleartextStream = tls.connect(8000, options, function() {
  console.log('client connected',
              cleartextStream.authorized ? 'authorized' : 'unauthorized');
  process.stdin.pipe(cleartextStream);
  process.stdin.resume();
});
cleartextStream.setEncoding('utf8');
cleartextStream.on('data', function(data) {
  console.log(data);
});
cleartextStream.on('end', function() {
  server.close();
});
</code></pre>

<h3>STARTTLS</h3>

<p>In the v0.4 branch no function exists for starting a TLS session on an<br />already existing TCP connection.  This is possible it just requires a bit of<br />work. The technique is to use <code>tls.createSecurePair()</code> which returns two<br />streams: an encrypted stream and a cleartext stream. The encrypted stream is<br />then piped to the socket, the cleartext stream is what the user interacts with<br />thereafter.</p>

<p><a href="http://gist.github.com/848444">Here is some code that does it.</a></p>

<h3>NPN and SNI</h3>

<p>NPN (Next Protocol Negotitation) and SNI (Server Name Indication) are TLS<br />handshake extensions allowing you:</p>

<ul>
<li>NPN - to use one TLS server for multiple protocols (HTTP, SPDY)</li>
<li>SNI - to use one TLS server for multiple hostnames with different SSL
certificates.</li>
</ul>

<h3>pair = tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])</h3>

<p>Creates a new secure pair object with two streams, one of which reads/writes<br />encrypted data, and one reads/writes cleartext data.<br />Generally the encrypted one is piped to/from an incoming encrypted data stream,<br />and the cleartext one is used as a replacement for the initial encrypted stream.</p>

<ul>
<li><p><code>credentials</code>: A credentials object from crypto.createCredentials( ... )</p></li>
<li><p><code>isServer</code>: A boolean indicating whether this tls connection should be<br />opened as a server or a client.</p></li>
<li><p><code>requestCert</code>: A boolean indicating whether a server should request a<br />certificate from a connecting client. Only applies to server connections.</p></li>
<li><p><code>rejectUnauthorized</code>: A boolean indicating whether a server should<br />automatically reject clients with invalid certificates. Only applies to<br />servers with <code>requestCert</code> enabled.</p></li>
</ul>

<p><code>tls.createSecurePair()</code> returns a SecurePair object with<br /><a href="#tls.CleartextStream">cleartext</a> and <code>encrypted</code> stream properties.</p>

<h4>Event: 'secure'</h4>

<p>The event is emitted from the SecurePair once the pair has successfully<br />established a secure connection.</p>

<p>Similarly to the checking for the server 'secureConnection' event,<br />pair.cleartext.authorized should be checked to confirm whether the certificate<br />used properly authorized.</p>

<h3>tls.Server</h3>

<p>This class is a subclass of <code>net.Server</code> and has the same methods on it.<br />Instead of accepting just raw TCP connections, this accepts encrypted<br />connections using TLS or SSL.</p>

<h4>Event: 'secureConnection'</h4>

<p><code>function (cleartextStream) {}</code></p>

<p>This event is emitted after a new connection has been successfully<br />handshaked. The argument is a instance of<br /><a href="#tls.CleartextStream">CleartextStream</a>. It has all the common stream methods<br />and events.</p>

<p><code>cleartextStream.authorized</code> is a boolean value which indicates if the<br />client has verified by one of the supplied certificate authorities for the<br />server. If <code>cleartextStream.authorized</code> is false, then<br /><code>cleartextStream.authorizationError</code> is set to describe how authorization<br />failed. Implied but worth mentioning: depending on the settings of the TLS<br />server, you unauthorized connections may be accepted.<br /><code>cleartextStream.npnProtocol</code> is a string containing selected NPN protocol.<br /><code>cleartextStream.servername</code> is a string containing servername requested with<br />SNI.</p>

<h4>server.listen(port, [host], [callback])</h4>

<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the<br /><code>host</code> is omitted, the server will accept connections directed to any<br />IPv4 address (<code>INADDR_ANY</code>).</p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be called<br />when the server has been bound.</p>

<p>See <code>net.Server</code> for more information.</p>

<h4>server.close()</h4>

<p>Stops the server from accepting new connections. This function is<br />asynchronous, the server is finally closed when the server emits a <code>'close'</code><br />event.</p>

<h4>server.address()</h4>

<p>Returns the bound address and port of the server as reported by the operating<br />system.<br />See <a href="net.html#server.address">net.Server.address()</a> for more information.</p>

<h4>server.addContext(hostname, credentials)</h4>

<p>Add secure context that will be used if client request's SNI hostname is<br />matching passed <code>hostname</code> (wildcards can be used). <code>credentials</code> can contain<br /><code>key</code>, <code>cert</code> and <code>ca</code>.</p>

<h4>server.maxConnections</h4>

<p>Set this property to reject connections when the server's connection count<br />gets high.</p>

<h4>server.connections</h4>

<p>The number of concurrent connections on the server.</p>

<h3>tls.CleartextStream</h3>

<p>This is a stream on top of the <em>Encrypted</em> stream that makes it possible to<br />read/write an encrypted data as a cleartext data.</p>

<p>This instance implements a duplex <a href="streams.html#streams">Stream</a> interfaces.<br />It has all the common stream methods and events.</p>

<h4>Event: 'secureConnect'</h4>

<p><code>function () {}</code></p>

<p>This event is emitted after a new connection has been successfully handshaked. <br />The listener will be called no matter if the server's certificate was<br />authorized or not. It is up to the user to test <code>cleartextStream.authorized</code><br />to see if the server certificate was signed by one of the specified CAs.<br />If <code>cleartextStream.authorized === false</code> then the error can be found in<br /><code>cleartextStream.authorizationError</code>. Also if NPN was used - you can check<br /><code>cleartextStream.npnProtocol</code> for negotiated protocol.</p>

<h4>cleartextStream.authorized</h4>

<p>A boolean that is <code>true</code> if the peer certificate was signed by one of the<br />specified CAs, otherwise <code>false</code></p>

<h4>cleartextStream.authorizationError</h4>

<p>The reason why the peer's certificate has not been verified. This property<br />becomes available only when <code>cleartextStream.authorized === false</code>.</p>

<h4>cleartextStream.getPeerCertificate()</h4>

<p>Returns an object representing the peer's certicicate. The returned object has<br />some properties corresponding to the field of the certificate.</p>

<p>Example:</p>

<pre><code>{ subject: 
   { C: 'UK',
     ST: 'Acknack Ltd',
     L: 'Rhys Jones',
     O: 'node.js',
     OU: 'Test TLS Certificate',
     CN: 'localhost' },
  issuer: 
   { C: 'UK',
     ST: 'Acknack Ltd',
     L: 'Rhys Jones',
     O: 'node.js',
     OU: 'Test TLS Certificate',
     CN: 'localhost' },
  valid_from: 'Nov 11 09:52:22 2009 GMT',
  valid_to: 'Nov  6 09:52:22 2029 GMT',
  fingerprint: '2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF' }
</code></pre>

<p>If the peer does not provide a certificate, it returns <code>null</code> or an empty<br />object.</p>

<h4>cleartextStream.address()</h4>

<p>Returns the bound address and port of the underlying socket as reported by the<br />operating system. Returns an object with two properties, e.g.<br /><code>{"address":"192.168.57.1", "port":62053}</code></p>

<h4>cleartextStream.remoteAddress</h4>

<p>The string representation of the remote IP address. For example,<br /><code>'74.125.127.100'</code> or <code>'2001:4860:a005::68'</code>.</p>

<h4>cleartextStream.remotePort</h4>

<p>The numeric representation of the remote port. For example, <code>443</code>.<br /></div></p></div>
</div>
<footer>
    <p>&nbsp;</p>
</footer>
        
<script type="text/javascript" src="../js/sh_main.js"></script>
<script type="text/javascript" src="../js/sh_javascript.min.js"></script>
</div>
    </div>

  </body>
</html>