<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Node.js Reference Guide</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/sh.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
      }
    </style>
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
  <script src="../js/toc.js"></script>
    <script type="text/javascript">
    $(document).ready(function() {
        //$("#toc").accordion({ event: 'mouseover' }, { autoHeight: false });
    });
    </script>
    <link href="../css/style_override.css" rel="stylesheet">
  </head>

  <body>
    <!--
        <div class="topbar">
          <div class="topbar-inner">
            <div class="container-fluid">
              <a class="brand" href="#">Project name</a>
              <ul class="nav">
                <li class="active"><a href="#">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#contact">Contact</a></li>
              </ul>
              <p class="pull-right">Logged in as <a href="#">username</a></p>
            </div>
          </div>
        </div>
    -->

    <div class="container-fluid">
      <div class="sidebar">
        <div id="toc" class="well">
        <h5>Node.js Reference Guide</h5>
<div>
<ul>
<li><a class="upper" href="globals.html">Global Objects</a></li>
<li><a class="upper" href="stdio.html">Printing to Console</a></li>
<li><a class="upper" href="timers.html">Timers</a></li>
<li><a class="upper" href="modules.html">Modules</a></li>
<li><a class="upper" href="addons.html">Addons</a></li>
<li><a class="upper" href="process.html">process</a></li>
<li><a class="upper" href="util.html">util</a></li>
<li><a class="upper" href="events.html">Events</a></li>
<li><a class="upper" href="buffers.html">Buffers</a></li>
<li><a class="upper" href="streams.html">Streams</a></li>
<li><a class="upper" href="crypto.html">Cryptography and OpenSSL</a></li>
<li><a class="upper" href="tls.html">Implementing TLS & SSL</a></li>
<li><a class="upper" href="fs.html">Working with the File System</a></li>
<li><a class="upper" href="net.html">net</a></li>
<li><a class="upper" href="dgram.html">UDP and Datagram Sockets</a></li>
<li><a class="upper" href="dns.html">DNS</a></li>
<li><a class="upper" href="http.html">HTTP</a></li>
<li><a class="upper" href="https.html">HTTPS</a></li>
<li><a class="upper" href="url.html">URL</a></li>
<li><a class="upper" href="querystring.html">Query String</a></li>
<li><a class="upper" href="readline.html">Readline</a></li>
<li><a class="upper" href="repl.html">REPL</a></li>
<li><a class="upper" href="vm.html">Executing JavaScript</a></li>
<li><a class="upper" href="child_processes.html">Child Processes</a></li>
<li><a class="upper" href="assert.html">Assert</a></li>
<li><a class="upper" href="tty.html">TTY</a></li>
<li><a class="upper" href="zlib.html">Zipping with zlib</a></li>
<li><a class="upper" href="os.html">Accessing the OS</a></li>
<li><a class="upper" href="debugger.html">Debugging Node.js</a></li>
<li><a class="upper" href="cluster.html">Clusters</a></li>
<li><a class="upper" href="appendix_1.html">A1: Third Party Modules</a></li>
</ul></div>
</div>
</div>
<div class="content"><p><div class="hero-unit"></p>

<p><a class="hiddenLink" id="modules"></a></p>

<h2>Modules</h2>

<p>Node.js has a simple module loading system. In Node.js, files and modules are in one-to-one correspondence. </p>

<p>For example, imagine a scenario where <code>foo.js</code> loads the module <code>circle.js</code> in the same directory.</p>

<p>The contents of <code>foo.js</code> are:</p>

<pre><code>var circle = require('./circle.js');
console.log( 'The area of a circle of radius 4 is '
           + circle.area(4));
</code></pre>

<p>The contents of <code>circle.js</code> are:</p>

<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};
</code></pre>

<p>The module <code>circle.js</code> has exported the functions <code>area()</code> and <code>circumference()</code>.  To export an object, add to the special <a href="#module.exports"><code>exports</code></a> object.</p>

<p>Variables local to a module are private. In this example, the variable <code>PI</code> is private to <code>circle.js</code>.</p>

<h3>Cycles</h3>

<p>Whenever there are circular <code>require()</code> calls, a module might not be done being executed when it is returned.</p>

<p>Consider this situation with the following files. In `a.js':</p>

<pre><code>console.log('a starting');
exports.done = false;
var b = require('./b.js');
console.log('in a, b.done = %j', b.done);
exports.done = true;
console.log('a done');
</code></pre>

<p>In <code>b.js</code>:</p>

<pre><code>console.log('b starting');
exports.done = false;
var a = require('./a.js');
console.log('in b, a.done = %j', a.done);
exports.done = true;
console.log('b done');
</code></pre>

<p>And in <code>main.js</code>:</p>

<pre><code>console.log('main starting');
var a = require('./a.js');
var b = require('./b.js');
console.log('in main, a.done=%j, b.done=%j', a.done, b.done);
</code></pre>

<p>When <code>main.js</code> loads <code>a.js</code>, <code>a.js</code> loads <code>b.js</code>. At that point, <code>b.js</code> tries to load <code>a.js</code>.  In order to prevent an infinite loop an "unfinished copy" of the <code>a.js</code> exports object is returned to the <code>b.js</code> module.  <code>b.js</code> then finishes loading, and its exports object is provided to the <code>a.js</code> module.</p>

<p>By the time <code>main.js</code> finishes loading both modules, they've both finished executing. The output of this program would thus be:</p>

<pre><code>$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true
</code></pre>

<p>If you have cyclic module dependencies in your program, make sure to plan accordingly.</p>

<h3>Core Modules</h3>

<p>Node.js has several modules compiled into the binary. These modules are described in greater detail elsewhere in this documentation.</p>

<p>The core modules are defined in Node's source in the <code>lib/</code> folder.</p>

<p>Core modules are always preferentially loaded if their identifier is passed to <code>require()</code>.  For instance, <code>require('http')</code> always returns the built in HTTP module, even if there is a file by that name.</p>

<h3>File Modules</h3>

<p>If the exact filename is not found, then Node.js attempts to load the required filename with the added extension of <code>.js</code>, <code>.json</code>, and then <code>.node</code>.</p>

<p><code>.js</code> files are interpreted as Javascript text files, and <code>.json</code> files are parsed as JSON text files. <code>.node</code> files are interpreted as compiled addon modules loaded with <code>dlopen</code>.</p>

<p>A module prefixed with <code>'/'</code> is an absolute path to the file.  For example, <code>require('/home/marco/foo.js')</code> loads the file at <code>/home/marco/foo.js</code>.</p>

<p>A module prefixed with <code>'./'</code> is relative to the file calling <code>require()</code>. That is, <code>circle.js</code> must be in the same directory as <code>foo.js</code> for <code>require('./circle')</code> to find it.</p>

<p>Without a leading <code>'/'</code> or <code>'./'</code> to indicate a file, the module is either a "core module" or is loaded from the <code>node_modules</code> folder.</p>

<p>For example, if the file at <code>'/home/ry/projects/foo.js'</code> is called by <code>require('bar.js')</code>, then Node.js looks for it in the following locations, in this order:</p>

<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>

<p>This allows programs to localize their dependencies, so that they do not clash.</p>

<h3>Folders as Modules</h3>

<p>It is convenient to organize programs and libraries into self-contained directories, and then provide a single entry point to that library. </p>

<p>There are three ways in which a folder may be passed to <code>require()</code> as an argument.</p>

<p>The first is to create a <code>package.json</code> file in the root of the folder, which specifies a <code>main</code> module.  An example <code>package.json</code> file might look like this:</p>

<pre><code>{ "name" : "some-library",
  "main" : "./lib/some-library.js" }
</code></pre>

<p>If this was in a folder at <code>./some-library</code>, then <code>require('./some-library')</code> would attempt to load <code>./some-library/lib/some-library.js</code>.</p>

<p>This is the extent of Node's awareness of <code>package.json</code> files.</p>

<p>If there is no <code>package.json</code> file present in the directory, then Node.js attempts to load an <code>index.js</code> or <code>index.node</code> file out of that directory.  For example, if there was no <code>package.json</code> file in the above example, then <code>require('./some-library')</code> would attempt to load:</p>

<ul>
<li><code>./some-library/index.js</code></li>
<li><code>./some-library/index.node</code></li>
</ul>

<h3>Caching</h3>

<p>Modules are cached after the first time they are loaded.  This means (among other things) that every call to <code>require('foo')</code> gets exactly the same object returned, if it would resolve to the same file.</p>

<p>Multiple calls to <code>require('foo')</code> may not cause the module code to be executed multiple times.  This is an important feature.  With it, "partially done" objects can be returned, thus allowing transitive dependencies to be loaded even when they would cause cycles.</p>

<p>If you want to have a module execute code multiple times, then export a function, and call that function.</p>

<h4>Module Caching Caveats</h4>

<p>Modules are cached based on their resolved filename.  Since modules may resolve to a different filename based on the location of the calling module (loading from <code>node_modules</code> folders), it is not a guarantee that <code>require('foo')</code> always returns the exact same object, if it would resolve to different files.</p>

<p><a id="module.exports"></a></p>

<h3>module.exports</h3>

<p>The <code>exports</code> object is created by the Module system. Sometimes, this is not<br />acceptable, as some developers want their module to be an instance of some class. </p>

<p>To do this assign the desired export object to <code>module.exports</code>. For example suppose we were making a module called <code>a.js</code></p>

<pre><code>var EventEmitter = require('events').EventEmitter;

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the 'ready' event from the module itself.
setTimeout(function() {
  module.exports.emit('ready');
}, 1000);
</code></pre>

<p>Then, in another file we could do</p>

<pre><code>var a = require('./a');
a.on('ready', function() {
  console.log('module a is ready');
});
</code></pre>

<p>Note that the assignment to <code>module.exports</code> must be done immediately. It cannot be done in any callbacks. For example, this does not work:</p>

<p>In a file called <code>x.js</code>:</p>

<pre><code>setTimeout(function() {
  module.exports = { a: "hello" };
}, 0);
</code></pre>

<p>In a file called <code>y.js</code>:</p>

<pre><code>var x = require('./x');
console.log(x.a);
</code></pre>

<h3><code>module.require</code></h3>

<p>The <code>module.require</code> method provides a way to load a module as if <code>require()</code> was called from the original module.</p>

<p>Note that in order to do this, you must get a reference to the <code>module</code> object.  Since <code>require()</code> returns the <code>exports</code>, and the <code>module</code> is typically <em>only</em> available within a specific module's code, it must be explicitly exported in order to be used.</p>

<h3>All Together Now</h3>

<p>To get the exact filename that will be loaded when <code>require()</code> is called, use the <code>require.resolve()</code> function.</p>

<p>Putting together all of the above, here is the high-level algorithm (in pseudocode) of what <code>require.resolve()</code> does:</p>

<p><dl><br /><dt>To <code>require(X)</code> from module at path Y:</dt><br /><dd><br />    <pre><br />    1. If X is a core module,<br />        a. return the core module<br />        b. STOP<br />    2. If X begins with './' or '/' or '../'<br />        a. LOAD_AS_FILE(Y + X)<br />        b. LOAD_AS_DIRECTORY(Y + X)<br />    3. LOAD_NODE_MODULES(X, dirname(Y))<br />    4. THROW "not found"<br />    </pre><br /></dd><br /><dt>To <code>LOAD_AS_FILE(X)</code>:</dt><br /><dd><br />    <pre><br />    1. If X is a file, load X as JavaScript text.  STOP<br />    2. If X.js is a file, load X.js as JavaScript text.  STOP<br />    3. If X.node is a file, load X.node as binary addon.  STOP<br />    </pre><br /><dd><br /><dt>To <code>LOAD_AS_DIRECTORY(X)</code>:</dt><br /><dd><br />    <pre><br />    1. If X/package.json is a file,<br />       a. Parse X/package.json, and look for "main" field.<br />       b. let M = X + (json main field)<br />       c. LOAD_AS_FILE(M)<br />    2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP<br />    3. If X/index.node is a file, load X/index.node as binary addon.  STOP<br />    </pre><br /></dd><br /><dt>To <code>LOAD_NODE_MODULES(X, START)</code>: </dt><br /><dd><br />    <pre><br />    1. let DIRS=NODE_MODULES_PATHS(START)<br />    2. for each DIR in DIRS:<br />       a. LOAD_AS_FILE(DIR/X)<br />       b. LOAD_AS_DIRECTORY(DIR/X)<br />    </pre><br /></dd><br /><dt>To <code>NODE_MODULES_PATHS(START)</code>: </dt><br /><dd><br />    <pre><br />    1. let PARTS = path split(START)<br />    2. let ROOT = index of first instance of "node_modules" in PARTS, or 0<br />    3. let I = count of PARTS - 1<br />    4. let DIRS = []<br />    5. while I > ROOT,<br />       a. if PARTS[I] = "node_modules" CONTINUE<br />       c. DIR = path join(PARTS[0 .. I] + "node_modules")<br />       b. DIRS = DIRS + DIR<br />       c. let I = I - 1<br />    6. return DIRS<br />    </pre><br /></dd></p>

<h3>Loading from the global folders</h3>

<p>If the <code>NODE_PATH</code> environment variable is set to a colon-delimited list of absolute paths, then Node.js searches those paths for modules if they are not found elsewhere. (Note: On Windows, <code>NODE_PATH</code> is delimited by semicolons instead of colons.)</p>

<p>Additionally, Node.js searches in the following locations:</p>

<ul>
<li>1: <code>$HOME/.node_modules</code></li>
<li>2: <code>$HOME/.node_libraries</code></li>
<li>3: <code>$PREFIX/lib/node</code></li>
</ul>

<p>Where <code>$HOME</code> is the user's home directory, and <code>$PREFIX</code> is Node's configured <code>installPrefix</code>.</p>

<p>These are mostly for historic reasons. You are highly encouraged to place your dependencies localy in <code>node_modules</code> folders.  They will be loaded faster, and more reliably.</p>

<h3>Accessing the <code>main</code> module</h3>

<p>When a file is run directly from Node.js, <code>require.main</code> is set to its <code>module</code>. That means that you can determine whether a file has been run directly by testing for the following:</p>

<pre><code>require.main === module
</code></pre>

<p>For a file <code>foo.js</code>, this is <code>true</code> if run via <code>node foo.js</code>, but <code>false</code> if run by <code>require('./foo')</code>.</p>

<p>Because <code>module</code> provides a <code>filename</code> property (normally equivalent to <code>__filename</code>), the entry point of the current application can be obtained by checking <code>require.main.filename</code>.</p>

<h3>Package Manager Tips</h3>

<p>The semantics of Node's <code>require()</code> function were designed to be general enough to support a number of sane directory structures. Package manager programs such as <code>dpkg</code>, <code>rpm</code>, and <code>npm</code> will hopefully find it possible to build native packages from Node modules without modification.</p>

<p>Below we give a suggested directory structure that could work:</p>

<p>Let's say that we wanted to have the folder at <code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> hold the contents of a specific version of a package.</p>

<p>Packages can depend on one another. In order to install package <code>foo</code>, you may have to install a specific version of package <code>bar</code>.  The <code>bar</code> package may itself have dependencies, and in some cases, these dependencies may even collide or form cycles.</p>

<p>Since Node.js looks up the <code>realpath</code> of any modules it loads (that is, resolves symlinks), and then looks for their dependencies in the <code>node_modules</code> folders as described above, this situation is very simple to resolve with the following architecture:</p>

<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - Contents of the <code>foo</code> package, version 1.2.3.</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - Contents of the <code>bar</code> package that <code>foo</code>
depends on.</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Symbolic link to
<code>/usr/lib/node/bar/4.3.2/</code>.</li>
<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Symbolic links to the packages
that <code>bar</code> depends on.</li>
</ul>

<p>Thus, even if a cycle is encountered, or if there are dependency conflicts, every module will be able to get a version of its dependency that it can use.</p>

<p>When the code in the <code>foo</code> package does <code>require('bar')</code>, it gets the version that is symlinked into <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>. Then, when the code in the <code>bar</code> package calls <code>require('quux')</code>, it gets the version that is symlinked into <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.</p>

<p>Furthermore, to make the module lookup process even more optimal, rather than putting packages directly in <code>/usr/lib/node</code>, we could put them in <code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Then Node.js doesn't bother looking for missing dependencies in <code>/usr/node_modules</code> or <code>/node_modules</code>.</p>

<p>In order to make modules available to the Node.js REPL, it might be useful to also add the <code>/usr/lib/node_modules</code> folder to the <code>$NODE_PATH</code> environment variable.  Since the module lookups using <code>node_modules</code> folders are all relative, and based on the real path of the files making the calls to <code>require()</code>, the packages themselves can be anywhere.<br /></div></p></div>
</div>
<footer>
    <p>&nbsp;</p>
</footer>
        
<script type="text/javascript" src="../js/sh_main.js"></script>
<script type="text/javascript" src="../js/sh_javascript.min.js"></script>
</div>
    </div>

  </body>
</html>