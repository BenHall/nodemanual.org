<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Node.js Reference Guide</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/sh.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
      }
    </style>
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
  <script src="../js/toc.js"></script>
    <script type="text/javascript">
    $(document).ready(function() {
        //$("#toc").accordion({ event: 'mouseover' }, { autoHeight: false });
    });
    </script>
    <link href="../css/style_override.css" rel="stylesheet">
  </head>

  <body>
    <!--
        <div class="topbar">
          <div class="topbar-inner">
            <div class="container-fluid">
              <a class="brand" href="#">Project name</a>
              <ul class="nav">
                <li class="active"><a href="#">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#contact">Contact</a></li>
              </ul>
              <p class="pull-right">Logged in as <a href="#">username</a></p>
            </div>
          </div>
        </div>
    -->

    <div class="container-fluid">
      <div class="sidebar">
        <div id="toc" class="well">
        <h5>Node.js Reference Guide</h5>
<div>
<ul>
<li><a class="upper" href="synopsis.html">Synopsis</a></li>
<li><a class="upper" href="globals.html">Global Objects</a></li>
<li><a class="upper" href="stdio.html">console</a></li>
<li><a class="upper" href="timers.html">Timers</a></li>
<li><a class="upper" href="modules.html">Modules</a></li>
<li><a class="upper" href="addons.html">Addons</a></li>
<li><a class="upper" href="process.html">process</a></li>
<li><a class="upper" href="util.html">util</a></li>
<li><a class="upper" href="events.html">Events</a></li>
<li><a class="upper" href="buffers.html">Buffers</a></li>
<li><a class="upper" href="streams.html">Streams</a></li>
<li><a class="upper" href="crypto.html">Crypto</a></li>
<li><a class="upper" href="tls.html">TLS (SSL)</a></li>
<li><a class="upper" href="fs.html">File System</a></li>
<li><a class="upper" href="net.html">net</a></li>
<li><a class="upper" href="dgram.html">UDP / Datagram Sockets</a></li>
<li><a class="upper" href="dns.html">DNS</a></li>
<li><a class="upper" href="http.html">HTTP</a></li>
<li><a class="upper" href="https.html">HTTPS</a></li>
<li><a class="upper" href="url.html">URL</a></li>
<li><a class="upper" href="querystring.html">Query String</a></li>
<li><a class="upper" href="readline.html">Readline</a></li>
<li><a class="upper" href="repl.html">REPL</a></li>
<li><a class="upper" href="vm.html">Executing JavaScript</a></li>
<li><a class="upper" href="child_processes.html">Child Processes</a></li>
<li><a class="upper" href="assert.html">Assert</a></li>
<li><a class="upper" href="tty.html">TTY</a></li>
<li><a class="upper" href="zlib.html">Zlib</a></li>
<li><a class="upper" href="os.html">os Module</a></li>
<li><a class="upper" href="debugger.html">Debugger</a></li>
<li><a class="upper" href="cluster.html">Cluster</a></li>
<li><a class="upper" href="appendix_1.html">Appendix 1 - Third Party Modules</a></li>
</ul></div>
</div>
</div>
<div class="content"><p><div class="hero-unit"></p>

<p><a class="hiddenLink" id="modules"></a></p>

<h2>Modules</h2>

<p>Node has a simple module loading system.  In Node, files and modules are in<br />one-to-one correspondence.  As an example, <code>foo.js</code> loads the module<br /><code>circle.js</code> in the same directory.</p>

<p>The contents of <code>foo.js</code>:</p>

<pre><code>var circle = require('./circle.js');
console.log( 'The area of a circle of radius 4 is '
           + circle.area(4));
</code></pre>

<p>The contents of <code>circle.js</code>:</p>

<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};
</code></pre>

<p>The module <code>circle.js</code> has exported the functions <code>area()</code> and<br /><code>circumference()</code>.  To export an object, add to the special <code>exports</code><br />object.</p>

<p>Variables<br />local to the module will be private. In this example the variable <code>PI</code> is<br />private to <code>circle.js</code>.</p>

<h3>Cycles</h3>

<p>When there are circular <code>require()</code> calls, a module might not be<br />done being executed when it is returned.</p>

<p>Consider this situation:</p>

<p><code>a.js</code>:</p>

<pre><code>console.log('a starting');
exports.done = false;
var b = require('./b.js');
console.log('in a, b.done = %j', b.done);
exports.done = true;
console.log('a done');
</code></pre>

<p><code>b.js</code>:</p>

<pre><code>console.log('b starting');
exports.done = false;
var a = require('./a.js');
console.log('in b, a.done = %j', a.done);
exports.done = true;
console.log('b done');
</code></pre>

<p><code>main.js</code>:</p>

<pre><code>console.log('main starting');
var a = require('./a.js');
var b = require('./b.js');
console.log('in main, a.done=%j, b.done=%j', a.done, b.done);
</code></pre>

<p>When <code>main.js</code> loads <code>a.js</code>, then <code>a.js</code> in turn loads <code>b.js</code>.  At that<br />point, <code>b.js</code> tries to load <code>a.js</code>.  In order to prevent an infinite<br />loop an <strong>unfinished copy</strong> of the <code>a.js</code> exports object is returned to the<br /><code>b.js</code> module.  <code>b.js</code> then finishes loading, and its exports object is<br />provided to the <code>a.js</code> module.</p>

<p>By the time <code>main.js</code> has loaded both modules, they're both finished.<br />The output of this program would thus be:</p>

<pre><code>$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true
</code></pre>

<p>If you have cyclic module dependencies in your program, make sure to<br />plan accordingly.</p>

<h3>Core Modules</h3>

<p>Node has several modules compiled into the binary.  These modules are<br />described in greater detail elsewhere in this documentation.</p>

<p>The core modules are defined in node's source in the <code>lib/</code> folder.</p>

<p>Core modules are always preferentially loaded if their identifier is<br />passed to <code>require()</code>.  For instance, <code>require('http')</code> will always<br />return the built in HTTP module, even if there is a file by that name.</p>

<h3>File Modules</h3>

<p>If the exact filename is not found, then node will attempt to load the<br />required filename with the added extension of <code>.js</code>, <code>.json</code>, and then <code>.node</code>.</p>

<p><code>.js</code> files are interpreted as JavaScript text files, and <code>.json</code> files are<br />parsed as JSON text files. <code>.node</code> files are interpreted as compiled addon<br />modules loaded with <code>dlopen</code>.</p>

<p>A module prefixed with <code>'/'</code> is an absolute path to the file.  For<br />example, <code>require('/home/marco/foo.js')</code> will load the file at<br /><code>/home/marco/foo.js</code>.</p>

<p>A module prefixed with <code>'./'</code> is relative to the file calling <code>require()</code>.<br />That is, <code>circle.js</code> must be in the same directory as <code>foo.js</code> for<br /><code>require('./circle')</code> to find it.</p>

<p>Without a leading '/' or './' to indicate a file, the module is either a<br />"core module" or is loaded from a <code>node_modules</code> folder.</p>

<h3>Loading from <code>node_modules</code> Folders</h3>

<p>If the module identifier passed to <code>require()</code> is not a native module,<br />and does not begin with <code>'/'</code>, <code>'../'</code>, or <code>'./'</code>, then node starts at the<br />parent directory of the current module, and adds <code>/node_modules</code>, and<br />attempts to load the module from that location.</p>

<p>If it is not found there, then it moves to the parent directory, and so<br />on, until the root of the tree is reached.</p>

<p>For example, if the file at <code>'/home/ry/projects/foo.js'</code> called<br /><code>require('bar.js')</code>, then node would look in the following locations, in<br />this order:</p>

<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>

<p>This allows programs to localize their dependencies, so that they do not<br />clash.</p>

<h3>Folders as Modules</h3>

<p>It is convenient to organize programs and libraries into self-contained<br />directories, and then provide a single entry point to that library.<br />There are three ways in which a folder may be passed to <code>require()</code> as<br />an argument.</p>

<p>The first is to create a <code>package.json</code> file in the root of the folder,<br />which specifies a <code>main</code> module.  An example package.json file might<br />look like this:</p>

<pre><code>{ "name" : "some-library",
  "main" : "./lib/some-library.js" }
</code></pre>

<p>If this was in a folder at <code>./some-library</code>, then<br /><code>require('./some-library')</code> would attempt to load<br /><code>./some-library/lib/some-library.js</code>.</p>

<p>This is the extent of Node's awareness of package.json files.</p>

<p>If there is no package.json file present in the directory, then node<br />will attempt to load an <code>index.js</code> or <code>index.node</code> file out of that<br />directory.  For example, if there was no package.json file in the above<br />example, then <code>require('./some-library')</code> would attempt to load:</p>

<ul>
<li><code>./some-library/index.js</code></li>
<li><code>./some-library/index.node</code></li>
</ul>

<h3>Caching</h3>

<p>Modules are cached after the first time they are loaded.  This means<br />(among other things) that every call to <code>require('foo')</code> will get<br />exactly the same object returned, if it would resolve to the same file.</p>

<p>Multiple calls to <code>require('foo')</code> may not cause the module code to be<br />executed multiple times.  This is an important feature.  With it,<br />"partially done" objects can be returned, thus allowing transitive<br />dependencies to be loaded even when they would cause cycles.</p>

<p>If you want to have a module execute code multiple times, then export a<br />function, and call that function.</p>

<h4>Module Caching Caveats</h4>

<p>Modules are cached based on their resolved filename.  Since modules may<br />resolve to a different filename based on the location of the calling<br />module (loading from <code>node_modules</code> folders), it is not a <em>guarantee</em><br />that <code>require('foo')</code> will always return the exact same object, if it<br />would resolve to different files.</p>

<h3>module.exports</h3>

<p>The <code>exports</code> object is created by the Module system. Sometimes this is not<br />acceptable, many want their module to be an instance of some class. To do this<br />assign the desired export object to <code>module.exports</code>. For example suppose we<br />were making a module called <code>a.js</code></p>

<pre><code>var EventEmitter = require('events').EventEmitter;

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the 'ready' event from the module itself.
setTimeout(function() {
  module.exports.emit('ready');
}, 1000);
</code></pre>

<p>Then in another file we could do</p>

<pre><code>var a = require('./a');
a.on('ready', function() {
  console.log('module a is ready');
});
</code></pre>

<p>Note that assignment to <code>module.exports</code> must be done immediately. It cannot be<br />done in any callbacks.  This does not work:</p>

<p>x.js:</p>

<pre><code>setTimeout(function() {
  module.exports = { a: "hello" };
}, 0);
</code></pre>

<p>y.js:</p>

<pre><code>var x = require('./x');
console.log(x.a);
</code></pre>

<h3>module.require</h3>

<p>The <code>module.require</code> method provides a way to load a module as if<br /><code>require()</code> was called from the original module.</p>

<p>Note that in order to do this, you must get a reference to the <code>module</code><br />object.  Since <code>require()</code> returns the <code>exports</code>, and the <code>module</code> is<br />typically <em>only</em> available within a specific module's code, it must be<br />explicitly exported in order to be used.</p>

<h3>All Together...</h3>

<p>To get the exact filename that will be loaded when <code>require()</code> is called, use<br />the <code>require.resolve()</code> function.</p>

<p>Putting together all of the above, here is the high-level algorithm<br />in pseudocode of what require.resolve does:</p>

<pre><code>require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with './' or '/' or '../'
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW "not found"

LOAD_AS_FILE(X)
1. If X is a file, load X as JavaScript text.  STOP
2. If X.js is a file, load X.js as JavaScript text.  STOP
3. If X.node is a file, load X.node as binary addon.  STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for "main" field.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP
3. If X/index.node is a file, load X/index.node as binary addon.  STOP

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index of first instance of "node_modules" in PARTS, or 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = "node_modules" CONTINUE
   c. DIR = path join(PARTS[0 .. I] + "node_modules")
   b. DIRS = DIRS + DIR
   c. let I = I - 1
6. return DIRS
</code></pre>

<h3>Loading from the global folders</h3>

<p>If the <code>NODE_PATH</code> environment variable is set to a colon-delimited list<br />of absolute paths, then node will search those paths for modules if they<br />are not found elsewhere.  (Note: On Windows, <code>NODE_PATH</code> is delimited by<br />semicolons instead of colons.)</p>

<p>Additionally, node will search in the following locations:</p>

<ul>
<li>1: <code>$HOME/.node_modules</code></li>
<li>2: <code>$HOME/.node_libraries</code></li>
<li>3: <code>$PREFIX/lib/node</code></li>
</ul>

<p>Where <code>$HOME</code> is the user's home directory, and <code>$PREFIX</code> is node's<br />configured <code>installPrefix</code>.</p>

<p>These are mostly for historic reasons.  You are highly encouraged to<br />place your dependencies localy in <code>node_modules</code> folders.  They will be<br />loaded faster, and more reliably.</p>

<h3>Accessing the main module</h3>

<p>When a file is run directly from Node, <code>require.main</code> is set to its<br /><code>module</code>. That means that you can determine whether a file has been run<br />directly by testing</p>

<pre><code>require.main === module
</code></pre>

<p>For a file <code>foo.js</code>, this will be <code>true</code> if run via <code>node foo.js</code>, but<br /><code>false</code> if run by <code>require('./foo')</code>.</p>

<p>Because <code>module</code> provides a <code>filename</code> property (normally equivalent to<br /><code>__filename</code>), the entry point of the current application can be obtained<br />by checking <code>require.main.filename</code>.</p>

<h2>Addenda: Package Manager Tips</h2>

<p>The semantics of Node's <code>require()</code> function were designed to be general<br />enough to support a number of sane directory structures. Package manager<br />programs such as <code>dpkg</code>, <code>rpm</code>, and <code>npm</code> will hopefully find it possible to<br />build native packages from Node modules without modification.</p>

<p>Below we give a suggested directory structure that could work:</p>

<p>Let's say that we wanted to have the folder at<br /><code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> hold the contents of a<br />specific version of a package.</p>

<p>Packages can depend on one another. In order to install package <code>foo</code>, you<br />may have to install a specific version of package <code>bar</code>.  The <code>bar</code> package<br />may itself have dependencies, and in some cases, these dependencies may even<br />collide or form cycles.</p>

<p>Since Node looks up the <code>realpath</code> of any modules it loads (that is,<br />resolves symlinks), and then looks for their dependencies in the<br /><code>node_modules</code> folders as described above, this situation is very simple to<br />resolve with the following architecture:</p>

<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - Contents of the <code>foo</code> package, version 1.2.3.</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - Contents of the <code>bar</code> package that <code>foo</code>
depends on.</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Symbolic link to
<code>/usr/lib/node/bar/4.3.2/</code>.</li>
<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Symbolic links to the packages
that <code>bar</code> depends on.</li>
</ul>

<p>Thus, even if a cycle is encountered, or if there are dependency<br />conflicts, every module will be able to get a version of its dependency<br />that it can use.</p>

<p>When the code in the <code>foo</code> package does <code>require('bar')</code>, it will get the<br />version that is symlinked into <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>.<br />Then, when the code in the <code>bar</code> package calls <code>require('quux')</code>, it'll get<br />the version that is symlinked into<br /><code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.</p>

<p>Furthermore, to make the module lookup process even more optimal, rather<br />than putting packages directly in <code>/usr/lib/node</code>, we could put them in<br /><code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Then node will not bother<br />looking for missing dependencies in <code>/usr/node_modules</code> or <code>/node_modules</code>.</p>

<p>In order to make modules available to the node REPL, it might be useful to<br />also add the <code>/usr/lib/node_modules</code> folder to the <code>$NODE_PATH</code> environment<br />variable.  Since the module lookups using <code>node_modules</code> folders are all<br />relative, and based on the real path of the files making the calls to<br /><code>require()</code>, the packages themselves can be anywhere.<br /></div></p></div>
</div>
<footer>
    <p>&nbsp;</p>
</footer>
        
<script type="text/javascript" src="../js/sh_main.js"></script>
<script type="text/javascript" src="../js/sh_javascript.min.js"></script>
</div>
    </div>

  </body>
</html>