<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Node.js Reference Guide</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/sh.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
      }
    </style>
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
  <script src="../js/toc.js"></script>
    <script type="text/javascript">
    $(document).ready(function() {
        //$("#toc").accordion({ event: 'mouseover' }, { autoHeight: false });
    });
    </script>
    <link href="../css/style_override.css" rel="stylesheet">
  </head>

  <body>
    <!--
        <div class="topbar">
          <div class="topbar-inner">
            <div class="container-fluid">
              <a class="brand" href="#">Project name</a>
              <ul class="nav">
                <li class="active"><a href="#">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#contact">Contact</a></li>
              </ul>
              <p class="pull-right">Logged in as <a href="#">username</a></p>
            </div>
          </div>
        </div>
    -->

    <div class="container-fluid">
      <div class="sidebar">
        <div id="toc" class="well">
        <h5>Node.js Reference Guide</h5>
<div>
<ul>
<li><a class="upper" href="globals.html">Global Objects</a></li>
<li><a class="upper" href="stdio.html">Printing to Console</a></li>
<li><a class="upper" href="timers.html">Timers</a></li>
<li><a class="upper" href="modules.html">Modules</a></li>
<li><a class="upper" href="addons.html">Addons</a></li>
<li><a class="upper" href="process.html">process</a></li>
<li><a class="upper" href="util.html">util</a></li>
<li><a class="upper" href="events.html">Events</a></li>
<li><a class="upper" href="buffers.html">Buffers</a></li>
<li><a class="upper" href="streams.html">Streams</a></li>
<li><a class="upper" href="crypto.html">Cryptography and OpenSSL</a></li>
<li><a class="upper" href="tls.html">Implementing TLS & SSL</a></li>
<li><a class="upper" href="fs.html">Working with the File System</a></li>
<li><a class="upper" href="net.html">net</a></li>
<li><a class="upper" href="dgram.html">UDP and Datagram Sockets</a></li>
<li><a class="upper" href="dns.html">DNS</a></li>
<li><a class="upper" href="http.html">HTTP</a></li>
<li><a class="upper" href="https.html">HTTPS</a></li>
<li><a class="upper" href="url.html">URL</a></li>
<li><a class="upper" href="querystring.html">Query String</a></li>
<li><a class="upper" href="readline.html">Readline</a></li>
<li><a class="upper" href="repl.html">REPL</a></li>
<li><a class="upper" href="vm.html">Executing JavaScript</a></li>
<li><a class="upper" href="child_processes.html">Child Processes</a></li>
<li><a class="upper" href="assert.html">Assert</a></li>
<li><a class="upper" href="tty.html">TTY</a></li>
<li><a class="upper" href="zlib.html">Zipping with zlib</a></li>
<li><a class="upper" href="os.html">Accessing the OS</a></li>
<li><a class="upper" href="debugger.html">Debugging Node.js</a></li>
<li><a class="upper" href="cluster.html">Clusters</a></li>
<li><a class="upper" href="appendix_1.html">A1: Third Party Modules</a></li>
</ul></div>
</div>
</div>
<div class="content"><p><div class="hero-unit"></p>

<p><a class="hiddenLink" id="udp-and-datagram-sockets"></a></p>

<h2>UDP and Datagram Sockets</h2>

<p>Datagram sockets are available by adding <code>require('dgram')</code> to your code.</p>

<h4>A Note About UDP Datagram Size</h4>

<p>The maximum size of an <code>IPv4/v6</code> datagram depends on the <code>MTU</code> (<em>Maximum Transmission Unit</em>) and on the <code>Payload Length</code> field size.</p>

<p>The <code>Payload Length</code> field is <code>16 bits</code> wide, which means that a normal payload can't be larger than 64K octets, including internet header and data: (65,507 bytes = 65,535 − 8 bytes UDP header − 20 bytes IP header). This is generally true for loopback interfaces, but such long datagrams are impractical for most hosts and networks.</p>

<p>The <code>MTU</code> is the largest size a given link layer technology can support for datagrams. For any link, IPv4 mandates a minimum <code>MTU</code> of <code>68</code> octets, while the recommended <code>MTU</code> for IPv4 is <code>576</code> (typically recommended as the <code>MTU</code> for dial-up type applications), whether they arrive whole or in fragments.</p>

<p>For <code>IPv6</code>, the minimum <code>MTU</code> is <code>1280</code> octets; however, the mandatory minimum fragment reassembly buffer size is <code>1500</code> octets. The value of <code>68</code> octets is very small, since most current link layer technologies have a minimum <code>MTU</code> of <code>1500</code> (like Ethernet).</p>

<p><strong>Note</strong>: it's impossible to know in advance the MTU of each link through which a packet might travel, and that generally sending a datagram greater than the (receiver) <code>MTU</code> won't work (the packet gets silently dropped, without informing the source that the data did not reach its intended recipient).</p>

<h3>Events</h3>

<p><h4 class="eventHeader"> <code>'message'</code></h4><div class="listenerParam"><h5>Listener Parameters</h5><ul><li><code>function (msg<div class="listenerParamParam"><h6>Parameters</h6><ul><li> rinfo)</code>: The callback to execute once the event fires</li><li> <code>msg</code>: A <code>Buffer</code></li><li> <code>rinfo</code>: An object with the sender's address information and the number of bytes in the datagram. </li></ul></li></ul></p>

<p>Emitted when a new datagram is available on a socket. </p>

<p><h4 class="eventHeader"> <code>'listening'</code></h4><div class="listenerParam"><h5>Listener Parameters</h5><ul><li><code>function ()</code>: The callback to execute once the event fires</li></ul></p>

<p>Emitted when a socket starts listening for datagrams. This happens as soon as UDP sockets are created.</p>

<p><h4 class="eventHeader"> <code>'close'</code></h4><div class="listenerParam"><h5>Listener Parameters</h5><ul><li><code>function ()</code>: The callback to execute once the event fires</li></ul></p>

<p>Emitted when a socket is closed with <code>close()</code>.  No new <code>message</code> events are emitted on this socket.</p>

<p><h4 class="eventHeader"> <code>'error'</code></h4><div class="listenerParam"><h5>Listener Parameters</h5><ul><li><code>function (exception)</code>: The callback to execute once the event fires<div class="listenerParamParam"><h6>Parameters</h6><ul><li> <code>exception</code>: The error that was encountered</li></ul></li></ul></p>

<p>Emitted when an error occurs.</p>

<p><h4 class="methodHeader"> <code>dgram.createSocket(type, [callback()])</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>type</code>: The type of socket to create; valid types are <code>udp4</code></ul></p>

<p>Creates a datagram socket of the specified types.</p>

<p>If you want to receive datagrams, call <code>socket.bind()</code>. <code>socket.bind()</code> binds to the "all interfaces" address on a random port (it does the right thing for both <code>udp4</code> and <code>udp6</code> sockets). You can then retrieve the address and port with <code>socket.address().address</code> and <code>socket.address().port</code>.</p>

<p><h4 class="methodHeader"> <code>dgram.send(buf, offset, length, port, address, [callback(err)])</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>buf</code>: The data buffer to send<li> <code>offset</code>: Indicates where in the buffer to start at</li><li> <code>length</code>: Indicates how much of the buffer to use</li><li> <code>port</code>: The port to send to</li><li> <code>address</code>: The address to send to</li><li> <code>[callback(err)]</code>: The callback to execute once the method completes</li><li> that may be used to detect any DNS errors and when <code>buf</code> may be reused</li></ul></p>

<p>Sends some information to a specified <code>address:port</code>. For UDP sockets, the destination port and IP address must be specified.  </p>

<p>A string may be supplied for the <code>address</code> parameter, and it will be resolved with DNS. Note that DNS lookups delay the time that a send takes place, at least until the next tick.  The only way to know for sure that a send has taken place<br />is to use the callback.</p>

<p>If the socket has not been previously bound with a call to <code>bind</code>, it's assigned a random port number and bound to the "all interfaces" address (0.0.0.0 for <code>udp4</code> sockets, ::0 for <code>udp6</code> sockets).</p>

<h4>Example</h4>

<p>Sending a UDP packet to a random port on <code>localhost</code>;</p>

<pre><code>var dgram = require('dgram');
var message = new Buffer("Some bytes");
var client = dgram.createSocket("udp4");
client.send(message, 0, message.length, 41234, "localhost", function(err, bytes) {
  client.close();
});
</code></pre>

<p><h4 class="methodHeader"> <code>dgram.bind(port, [address])</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>port</code>: The port to bind to<li> <code>address</code>: The address to attach to</li></ul></p>

<p>For UDP sockets, listen for datagrams on a named <code>port</code> and optional <code>address</code>. If <code>address</code> isn't specified, the OS tries to listen on all addresses.</p>

<h4>Example</h4>

<p>Example of a UDP server listening on port 41234:</p>

<pre><code>var dgram = require("dgram");

var server = dgram.createSocket("udp4");

server.on("message", function (msg, rinfo) {
  console.log("server got: " + msg + " from " +
    rinfo.address + ":" + rinfo.port);
});

server.on("listening", function () {
  var address = server.address();
  console.log("server listening " +
      address.address + ":" + address.port);
});

server.bind(41234);
// server listening 0.0.0.0:41234
</code></pre>

<p><h4 class="methodHeader"> <code>dgram.close()</code></h4></p>

<p>Close the underlying socket and stop listening for data on it.</p>

<p><h4 class="methodHeader"> <code>dgram.address()</code></h4></p>

<p>Returns an object containing the address information for a socket.  For UDP sockets, this object contains <code>address</code> and <code>port</code>.</p>

<p><h4 class="methodHeader"> <code>dgram.setBroadcast(flag)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>flag</code>: The value of <code>SO_BROADCAST</code></ul></p>

<p>Sets or clears the <code>SO_BROADCAST</code> socket option.  When this option is set, UDP packets may be sent to a local interface's broadcast address.</p>

<p><h4 class="methodHeader"> <code>dgram.setTTL(ttl)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>ttl</code>: The value of <code>IP_TTL</code></ul></p>

<p>Sets the <code>IP_TTL</code> socket option. TTL stands for "Time to Live," but in this context it specifies the number of IP hops that a packet is allowed to go through. Each router or gateway that forwards a packet decrements the TTL.  If the TTL is decremented to 0 by a router, it will not be forwarded.  Changing TTL values is typically done for network probes or when multicasting.</p>

<p>The argument to <code>setTTL()</code> is a number of hops between 1 and 255.  The default on most systems is 64.</p>

<p><h4 class="methodHeader"> <code>dgram.setMulticastTTL(ttl)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>ttl</code>: The value of <code>IP_MULTICAST_TTL</code></ul></p>

<p>Sets the <code>IP_MULTICAST_TTL</code> socket option.  TTL stands for "Time to Live," but in this context it specifies the number of IP hops that a packet is allowed to go through, specifically for multicast traffic.  Each router or gateway that forwards a packet decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.</p>

<p>The argument to <code>setMulticastTTL()</code> is a number of hops between 0 and 255.  The default on most systems is 64.</p>

<p><h4 class="methodHeader"> <code>dgram.setMulticastLoopback(flag)</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>flag</code>: The value of <code>IP_MULTICAST_LOOP</code></ul></p>

<p>Sets or clears the <code>IP_MULTICAST_LOOP</code> socket option.  When this option is set, multicast packets will also be received on the local interface.</p>

<p><h4 class="methodHeader"> <code>dgram.addMembership(multicastAddress, [multicastInterface])</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>multicastAddress</code>: The address to add<li> <code>[multicastInterface]</code>: The interface to use</li></ul></p>

<p>Tells the kernel to join a multicast group with the <code>IP_ADD_MEMBERSHIP</code> socket option.</p>

<p>If <code>multicastInterface</code> is not specified, the OS will try to add membership to all valid interfaces.</p>

<p><h4 class="methodHeader"> <code>dgram.dropMembership(multicastAddress, [multicastInterface])</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>multicastAddress</code>: The address to drop<li> <code>[multicastInterface]</code>: The interface to use</li></ul></p>

<p>Opposite of <code>addMembership</code>&mdash;this tells the kernel to leave a multicast group with <code>IP_DROP_MEMBERSHIP</code> socket option. This is automatically called by the kernel when the socket is closed or process terminates, so most apps will never need to call this.</p>

<p>If <code>multicastInterface</code> is not specified, the OS will try to drop membership to all valid interfaces.<br /></div></p></div>
</div>
<footer>
    <p>&nbsp;</p>
</footer>
        
<script type="text/javascript" src="../js/sh_main.js"></script>
<script type="text/javascript" src="../js/sh_javascript.min.js"></script>
</div>
    </div>

  </body>
</html>