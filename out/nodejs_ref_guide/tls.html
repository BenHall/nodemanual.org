<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Node.js Reference Guide</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/sh.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
      }
    </style>
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
  <script src="../js/toc.js"></script>
    <script type="text/javascript">
    $(document).ready(function() {
        //$("#toc").accordion({ event: 'mouseover' }, { autoHeight: false });
    });
    </script>
    <link href="../css/style_override.css" rel="stylesheet">
  </head>

  <body>
    <!--
        <div class="topbar">
          <div class="topbar-inner">
            <div class="container-fluid">
              <a class="brand" href="#">Project name</a>
              <ul class="nav">
                <li class="active"><a href="#">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#contact">Contact</a></li>
              </ul>
              <p class="pull-right">Logged in as <a href="#">username</a></p>
            </div>
          </div>
        </div>
    -->

    <div class="container-fluid">
      <div class="sidebar">
        <div id="toc" class="well">
        <h5>Node.js Reference Guide</h5>
<div>
<ul>
<li><a class="upper" href="globals.html">Global Objects</a></li>
<li><a class="upper" href="stdio.html">Printing to Console</a></li>
<li><a class="upper" href="timers.html">Timers</a></li>
<li><a class="upper" href="modules.html">Modules</a></li>
<li><a class="upper" href="addons.html">Addons</a></li>
<li><a class="upper" href="process.html">process</a></li>
<li><a class="upper" href="util.html">util</a></li>
<li><a class="upper" href="events.html">Events</a></li>
<li><a class="upper" href="buffers.html">Buffers</a></li>
<li><a class="upper" href="streams.html">Streams</a></li>
<li><a class="upper" href="crypto.html">Cryptography and OpenSSL</a></li>
<li><a class="upper" href="tls.html">Implementing TLS & SSL</a></li>
<li><a class="upper" href="fs.html">File System</a></li>
<li><a class="upper" href="net.html">net</a></li>
<li><a class="upper" href="dgram.html">UDP / Datagram Sockets</a></li>
<li><a class="upper" href="dns.html">DNS</a></li>
<li><a class="upper" href="http.html">HTTP</a></li>
<li><a class="upper" href="https.html">HTTPS</a></li>
<li><a class="upper" href="url.html">URL</a></li>
<li><a class="upper" href="querystring.html">Query String</a></li>
<li><a class="upper" href="readline.html">Readline</a></li>
<li><a class="upper" href="repl.html">REPL</a></li>
<li><a class="upper" href="vm.html">Executing JavaScript</a></li>
<li><a class="upper" href="child_processes.html">Child Processes</a></li>
<li><a class="upper" href="assert.html">Assert</a></li>
<li><a class="upper" href="tty.html">TTY</a></li>
<li><a class="upper" href="zlib.html">Zlib</a></li>
<li><a class="upper" href="os.html">os Module</a></li>
<li><a class="upper" href="debugger.html">Debugger</a></li>
<li><a class="upper" href="cluster.html">Cluster</a></li>
<li><a class="upper" href="appendix_1.html">Appendix 1 - Third Party Modules</a></li>
</ul></div>
</div>
</div>
<div class="content"><p><div class="hero-unit"></p>

<p><a class="hiddenLink" id="implementing-tls-ssl"></a></p>

<h2>Implementing TLS &amp; SSL</h2>

<p>The <code>tls</code> module uses OpenSSL to provide both the Transport Layer Security and the Secure Socket Layer; in other words, encrypted stream communications. </p>

<p>TLS/SSL is a public/private key infrastructure. Each client and each server must have a private key. A private key is created in your terminal like this:</p>

<pre><code>openssl genrsa -out ryans-key.pem 1024
</code></pre>

<p>where <code>ryans-key.pm</code> is the name of your file. All servers (and some clients) need to have a certificate. Certificates are public keys signed by a Certificate Authority&mdash;or they are self-signed. The first step to getting a certificate is to create a "Certificate Signing Request" (CSR) file. This is done using:</p>

<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem
</code></pre>

<p>To create a self-signed certificate with the CSR, enter this:</p>

<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem
</code></pre>

<p>Alternatively, you can send the CSR to a Certificate Authority for signing.</p>

<p>(Docs on creating a CA are pending;, for now, interested users should just look at <code>test/fixtures/keys/Makefile</code> in the Node.js source code.)</p>

<p>To access this module, add <code>require('tls')</code> in your code. </p>

<h3>Using STARTTLS</h3>

<p>As of the v0.4 Node.js branch, no function exists for starting a TLS session on an already existing TCP connection.  This is possible, but it requires a bit of<br />work. </p>

<p>The technique is to use <code>tls.createSecurePair()</code>, which returns two streams: an encrypted stream and a cleartext stream. The encrypted stream is then piped to the socket, the cleartext stream is what the user interacts with thereafter.</p>

<p><a href="http://gist.github.com/848444">Here is a gist that does it.</a></p>

<h3>Using NPN and SNI</h3>

<p>NPN (Next Protocol Negotitation) and SNI (Server Name Indication) are TLS handshake extensions. </p>

<p>NPN is to use one TLS server for multiple protocols (HTTP, SPDY)</p>

<p>SNI is to use one TLS server for multiple hostnames with different SSL certificates.</p>

<h3>Events</h3>

<p><h4 class="eventHeader"> <code>'secure'</code></h4><div class="listenerParam"><h5>Listener Parameters</h5><ul><li><code>function()</code>: The callback to execute once the event fires</li></ul></p>

<p>The event is emitted from the SecurePair once the pair has successfully established a secure connection.</p>

<p>Similarly to the checking for the server <code>'secureConnection'</code> event, `pair.cleartext.authorized should be checked to confirm whether the certificate<br />used properly authorized.</p>

<h4>Event: 'secureConnect'</h4>

<p>@cb <code>function()</code>: The callback to execute once the event fires</p>

<p>This event is emitted after a new connection has been successfully handshaked. <br />The listener will be called no matter if the server's certificate was<br />authorized or not. It is up to the user to test <code>cleartextStream.authorized</code><br />to see if the server certificate was signed by one of the specified CAs.<br />If <code>cleartextStream.authorized === false</code> then the error can be found in<br /><code>cleartextStream.authorizationError</code>. Also if NPN was used - you can check<br /><code>cleartextStream.npnProtocol</code> for negotiated protocol.</p>

<h4>Event: 'secureConnection'</h4>

<p>@cb <code>function()</code>: The callback to execute once the event fires, <code>cleartextStream</code>: A boolean value indicating if the client has verified by one of the supplied certificate authorities for the server.</p>

<p>This event is emitted after a new connection has been successfully<br />handshaked. The argument is a instance of<br /><a href="#tls.CleartextStream">CleartextStream</a>. It has all the common stream methods<br />and events.</p>

<p><code>cleartextStream.authorized</code> is  If <code>cleartextStream.authorized</code> is false, then<br /><code>cleartextStream.authorizationError</code> is set to describe how authorization<br />failed. Implied but worth mentioning: depending on the settings of the TLS<br />server, you unauthorized connections may be accepted.<br /><code>cleartextStream.npnProtocol</code> is a string containing selected NPN protocol.<br /><code>cleartextStream.servername</code> is a string containing servername requested with<br />SNI.</p>

<h3>TLS Methods</h3>

<p><h4 class="methodHeader"> <code>tls.connect(port, [host=localhost], [options], [secureConnectListener])</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>port</code>: The port to connect to<li> <code>host</code>: An optional hostname to connect to; defaults to <code>localhost</code></li><li> <code>options</code>: Any options you want to pass to the server</li><li> <code>secureConnectionListener</code>: An optional listener</li></ul></p>

<p>Creates a new client connection to the given <code>port</code> and <code>host</code>. This function returns a <a href="#tls.CleartextStream"><code>CleartextStream</code></a> object.</p>

<p><code>options</code> should be an object that specifies the following values:</p>

<ul>
<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the client in aPEM format.</p></li>
<li><p><code>passphrase</code>: A string of a passphrase for the private key.</p></li>
<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the client in a PEM format.</p></li>
<li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. These are used to authorize connections. If this is omitted, several "well-known root" CAs will be used, like VeriSign. </p></li>
<li><p><code>NPNProtocols</code>: An array of strings or a  <code>Buffer</code> containing supported NPN protocols. <br />    <code>Buffer</code> should have the following format: <code>0x05hello0x05world</code>, where the preceding byte indicates the following protocol name's length. Passing an array is usually much simplier: <code>['hello', 'world']</code>. <br />    Protocols should be ordered by their priority.</p></li>
<li><p><code>servername</code>: The server name for the SNI (Server Name Indication) TLS extension.</p></li>
</ul>

<p><code>secureConnectionListener</code> automatically sets a listener for the<br /><a href="#event_secureConnection_">secureConnection</a> event.</p>

<h4>Example</h4>

<p>Here's an example of a client connecting to an echo server:</p>

<pre><code>var tls = require('tls');
var fs = require('fs');

var options = {
  // These are necessary only if using the client certificate authentication
  key: fs.readFileSync('client-key.pem'),
  cert: fs.readFileSync('client-cert.pem'),

  // This is necessary only if the server uses the self-signed certificate
  ca: [ fs.readFileSync('server-cert.pem') ]
};

var cleartextStream = tls.connect(8000, options, function() {
  console.log('client connected',
              cleartextStream.authorized ? 'authorized' : 'unauthorized');
  process.stdin.pipe(cleartextStream);
  process.stdin.resume();
});
cleartextStream.setEncoding('utf8');
cleartextStream.on('data', function(data) {
  console.log(data);
});
cleartextStream.on('end', function() {
  server.close();
});
</code></pre>

<p><h4 class="methodHeader"> <code>pair = tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>credentials</code>: An optional credentials object from <code>crypto.createCredentials( ... )</code><li> <code>isServer</code>: An optional boolean indicating whether this TLS connection should be opened as a server (<code>true</code>) or a client (<code>false</code>)</li><li> <code>requestCert</code>: A boolean indicating whether a server should request a certificate from a connecting client; only applies to server connections</li><li> <code>rejectUnauthorized</code>: A boolean indicating whether a server should automatically reject clients with invalid certificates; only applies to servers with <code>requestCert</code> enabled</li></ul></p>

<p>Creates a new secure <code>pair</code> object with two streams, one of which reads/writes<br />encrypted data, and one reads/writes cleartext data. This function returns a SecurePair object with <a href="#tls.CleartextStream">cleartext</a> and <code>encrypted</code> stream properties.</p>

<p>Generally, the encrypted one is piped to/from an incoming encrypted data stream,<br />and the cleartext one is used as a replacement for the initial encrypted stream.</p>

<p><h4 class="methodHeader"> <code>tls.createServer(options, [secureConnectionListener])</code></h4><div class="methodParam"><h5>Parameters</h5><ul><li><code>options</code>: Any options you want to pass to the server<li> <code>secureConnectionListener</code>: An optional listener</li></ul></p>

<p>Creates a new <a href="#tls.Server">tls.Server</a>.</p>

<p>The <code>options</code> object has a mix of required and optional values:</p>

<ul>
<li><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in a PEM format. (Required)</li>
<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the server in a PEM format. (Required)</p></li>
<li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. These are used to authorize connections. If this is omitted, several "well-known root" CAs will be used, like VeriSign. </p></li>
<li><p><code>NPNProtocols</code>: An array of strings or a  <code>Buffer</code> containing supported NPN protocols. <br />    <code>Buffer</code> should have the following format: <code>0x05hello0x05world</code>, where the preceding byte indicates the following protocol name's length. Passing an array is usually much simplier: <code>['hello', 'world']</code>. <br />    Protocols should be ordered by their priority.</p></li>
<li><p><code>passphrase</code>: A string of a passphrase for the private key.</p></li>
<li><p><code>rejectUnauthorized</code>: If <code>true</code> the server rejects any connection that is not authorized with the list of supplied CAs. This option only has an effect if <code>requestCert</code> is <code>true</code>. This defaults to <code>false</code>.</p></li>
<li><p><code>requestCert</code>: If <code>true</code> the server requests a certificate from clients that connect and attempt to verify that certificate. This defaults to <code>false</code>.</p></li>
<li><p><code>sessionIdContext</code>: A string containing an opaque identifier for session resumption. If <code>requestCert</code> is <code>true</code>, the default is an MD5 hash value generated from the command line. Otherwise, the default is not provided.</p></li>
<li><p><code>SNICallback</code>: A function that is called if the client supports the SNI TLS extension. Only one argument will be passed to it: <code>servername</code>. <code>SNICallback</code> should return a SecureContext instance. You can use <code>crypto.createCredentials(...).context</code> to get a proper SecureContext. If <code>SNICallback</code> wasn't provided, a default callback within the high-level API is used (for more information, see below).</p></li>
</ul>

<p><code>secureConnectionListener</code> automatically sets a listener for the<br /><a href="#event_secureConnection_">secureConnection</a> event.</p>

<h4>Example</h4>

<p>Here's a simple "echo" server:</p>

<pre><code>var tls = require('tls');
var fs = require('fs');

var options = {
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem'),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,

  // This is necessary only if the client uses the self-signed certificate.
  ca: [ fs.readFileSync('client-cert.pem') ]
};

var server = tls.createServer(options, function(cleartextStream) {
  console.log('server connected',
              cleartextStream.authorized ? 'authorized' : 'unauthorized');
  cleartextStream.write("welcome!\n");
  cleartextStream.setEncoding('utf8');
  cleartextStream.pipe(cleartextStream);
});
server.listen(8000, function() {
  console.log('server bound');
});
</code></pre>

<p>You can test this server by connecting to it with <code>openssl s_client</code>:</p>

<pre><code>openssl s_client -connect 127.0.0.1:8000
</code></pre>

<h3>tls.Server</h3>

<p>This class is a subclass of <code>net.Server</code> and has the same methods on it.<br />Instead of accepting just raw TCP connections, this accepts encrypted<br />connections using TLS or SSL.</p>

<h4>server.listen(port, [host], [callback])</h4>

<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the<br /><code>host</code> is omitted, the server will accept connections directed to any<br />IPv4 address (<code>INADDR_ANY</code>).</p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be called<br />when the server has been bound.</p>

<p>See <code>net.Server</code> for more information.</p>

<h4>server.close()</h4>

<p>Stops the server from accepting new connections. This function is<br />asynchronous, the server is finally closed when the server emits a <code>'close'</code><br />event.</p>

<h4>server.address()</h4>

<p>Returns the bound address and port of the server as reported by the operating<br />system.<br />See <a href="net.html#server.address">net.Server.address()</a> for more information.</p>

<h4>server.addContext(hostname, credentials)</h4>

<p>Add secure context that will be used if client request's SNI hostname is<br />matching passed <code>hostname</code> (wildcards can be used). <code>credentials</code> can contain<br /><code>key</code>, <code>cert</code> and <code>ca</code>.</p>

<h4>server.maxConnections</h4>

<p>Set this property to reject connections when the server's connection count<br />gets high.</p>

<h4>server.connections</h4>

<p>The number of concurrent connections on the server.</p>

<h3>tls.CleartextStream</h3>

<p>This is a stream on top of the <em>Encrypted</em> stream that makes it possible to<br />read/write an encrypted data as a cleartext data.</p>

<p>This instance implements a duplex <a href="streams.html#streams">Stream</a> interfaces.<br />It has all the common stream methods and events.</p>

<h4>cleartextStream.authorized</h4>

<p>A boolean that is <code>true</code> if the peer certificate was signed by one of the<br />specified CAs, otherwise <code>false</code></p>

<h4>cleartextStream.authorizationError</h4>

<p>The reason why the peer's certificate has not been verified. This property<br />becomes available only when <code>cleartextStream.authorized === false</code>.</p>

<h4>cleartextStream.getPeerCertificate()</h4>

<p>Returns an object representing the peer's certicicate. The returned object has<br />some properties corresponding to the field of the certificate.</p>

<p>Example:</p>

<pre><code>{ subject: 
   { C: 'UK',
     ST: 'Acknack Ltd',
     L: 'Rhys Jones',
     O: 'node.js',
     OU: 'Test TLS Certificate',
     CN: 'localhost' },
  issuer: 
   { C: 'UK',
     ST: 'Acknack Ltd',
     L: 'Rhys Jones',
     O: 'node.js',
     OU: 'Test TLS Certificate',
     CN: 'localhost' },
  valid_from: 'Nov 11 09:52:22 2009 GMT',
  valid_to: 'Nov  6 09:52:22 2029 GMT',
  fingerprint: '2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF' }
</code></pre>

<p>If the peer does not provide a certificate, it returns <code>null</code> or an empty<br />object.</p>

<h4>cleartextStream.address()</h4>

<p>Returns the bound address and port of the underlying socket as reported by the<br />operating system. Returns an object with two properties, e.g.<br /><code>{"address":"192.168.57.1", "port":62053}</code></p>

<h4>cleartextStream.remoteAddress</h4>

<p>The string representation of the remote IP address. For example,<br /><code>'74.125.127.100'</code> or <code>'2001:4860:a005::68'</code>.</p>

<h4>cleartextStream.remotePort</h4>

<p>The numeric representation of the remote port. For example, <code>443</code>.<br /></div></p></div>
</div>
<footer>
    <p>&nbsp;</p>
</footer>
        
<script type="text/javascript" src="../js/sh_main.js"></script>
<script type="text/javascript" src="../js/sh_javascript.min.js"></script>
</div>
    </div>

  </body>
</html>