<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Node.js Reference Guide</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/sh.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
      }
    </style>
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
  <script src="../js/toc.js"></script>
    <script type="text/javascript">
    $(document).ready(function() {
        //$("#toc").accordion({ event: 'mouseover' }, { autoHeight: false });
    });
    </script>
    <link href="../css/style_override.css" rel="stylesheet">
  </head>

  <body>
    <!--
        <div class="topbar">
          <div class="topbar-inner">
            <div class="container-fluid">
              <a class="brand" href="#">Project name</a>
              <ul class="nav">
                <li class="active"><a href="#">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#contact">Contact</a></li>
              </ul>
              <p class="pull-right">Logged in as <a href="#">username</a></p>
            </div>
          </div>
        </div>
    -->

    <div class="container-fluid">
      <div class="sidebar">
        <div id="toc" class="well">
        <h5>Node.js Reference Guide</h5>
<div>
<ul>
<li><a class="upper" href="globals.html">Global Objects</a></li>
<li><a class="upper" href="stdio.html">Printing to Console</a></li>
<li><a class="upper" href="timers.html">Timers</a></li>
<li><a class="upper" href="modules.html">Modules</a></li>
<li><a class="upper" href="addons.html">Addons</a></li>
<li><a class="upper" href="process.html">process</a></li>
<li><a class="upper" href="util.html">util</a></li>
<li><a class="upper" href="events.html">Events</a></li>
<li><a class="upper" href="buffers.html">Buffers</a></li>
<li><a class="upper" href="streams.html">Streams</a></li>
<li><a class="upper" href="crypto.html">Cryptography and OpenSSL</a></li>
<li><a class="upper" href="tls.html">Implementing TLS & SSL</a></li>
<li><a class="upper" href="fs.html">File System</a></li>
<li><a class="upper" href="net.html">net</a></li>
<li><a class="upper" href="dgram.html">UDP / Datagram Sockets</a></li>
<li><a class="upper" href="dns.html">DNS</a></li>
<li><a class="upper" href="http.html">HTTP</a></li>
<li><a class="upper" href="https.html">HTTPS</a></li>
<li><a class="upper" href="url.html">URL</a></li>
<li><a class="upper" href="querystring.html">Query String</a></li>
<li><a class="upper" href="readline.html">Readline</a></li>
<li><a class="upper" href="repl.html">REPL</a></li>
<li><a class="upper" href="vm.html">Executing JavaScript</a></li>
<li><a class="upper" href="child_processes.html">Child Processes</a></li>
<li><a class="upper" href="assert.html">Assert</a></li>
<li><a class="upper" href="tty.html">TTY</a></li>
<li><a class="upper" href="zlib.html">Zlib</a></li>
<li><a class="upper" href="os.html">os Module</a></li>
<li><a class="upper" href="debugger.html">Debugger</a></li>
<li><a class="upper" href="cluster.html">Cluster</a></li>
<li><a class="upper" href="appendix_1.html">Appendix 1 - Third Party Modules</a></li>
</ul></div>
</div>
</div>
<div class="content"><p><div class="hero-unit"></p>

<p><a class="hiddenLink" id="file-system"></a></p>

<h2>File System</h2>

<p>File I/O is provided by simple wrappers around standard POSIX functions.  To<br />use this module do <code>require('fs')</code>. All the methods have asynchronous and<br />synchronous forms.</p>

<p>The asynchronous form always take a completion callback as its last argument.<br />The arguments passed to the completion callback depend on the method, but the<br />first argument is always reserved for an exception. If the operation was<br />completed successfully, then the first argument will be <code>null</code> or <code>undefined</code>.</p>

<p>When using the synchronous form any exceptions are immediately thrown.<br />You can use try/catch to handle exceptions or allow them to bubble up.</p>

<p>Here is an example of the asynchronous version:</p>

<pre><code>var fs = require('fs');

fs.unlink('/tmp/hello', function (err) {
  if (err) throw err;
  console.log('successfully deleted /tmp/hello');
});
</code></pre>

<p>Here is the synchronous version:</p>

<pre><code>var fs = require('fs');

fs.unlinkSync('/tmp/hello')
console.log('successfully deleted /tmp/hello');
</code></pre>

<p>With the asynchronous methods there is no guaranteed ordering. So the<br />following is prone to error:</p>

<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {
  if (err) throw err;
  console.log('renamed complete');
});
fs.stat('/tmp/world', function (err, stats) {
  if (err) throw err;
  console.log('stats: ' + JSON.stringify(stats));
});
</code></pre>

<p>It could be that <code>fs.stat</code> is executed before <code>fs.rename</code>.<br />The correct way to do this is to chain the callbacks.</p>

<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {
  if (err) throw err;
  fs.stat('/tmp/world', function (err, stats) {
    if (err) throw err;
    console.log('stats: ' + JSON.stringify(stats));
  });
});
</code></pre>

<p>In busy processes, the programmer is <em>strongly encouraged</em> to use the<br />asynchronous versions of these calls. The synchronous versions will block<br />the entire process until they complete--halting all connections.</p>

<p>Relative path to filename can be used, remember however that this path will be relative<br />to <code>process.cwd()</code>.</p>

<h3>fs.rename(path1, path2, [callback])</h3>

<p>Asynchronous rename(2). No arguments other than a possible exception are given<br />to the completion callback.</p>

<h3>fs.renameSync(path1, path2)</h3>

<p>Synchronous rename(2).</p>

<h3>fs.truncate(fd, len, [callback])</h3>

<p>Asynchronous ftruncate(2). No arguments other than a possible exception are<br />given to the completion callback.</p>

<h3>fs.truncateSync(fd, len)</h3>

<p>Synchronous ftruncate(2).</p>

<h3>fs.chown(path, uid, gid, [callback])</h3>

<p>Asynchronous chown(2). No arguments other than a possible exception are given<br />to the completion callback.</p>

<h3>fs.chownSync(path, uid, gid)</h3>

<p>Synchronous chown(2).</p>

<h3>fs.fchown(fd, uid, gid, [callback])</h3>

<p>Asynchronous fchown(2). No arguments other than a possible exception are given<br />to the completion callback.</p>

<h3>fs.fchownSync(fd, uid, gid)</h3>

<p>Synchronous fchown(2).</p>

<h3>fs.lchown(path, uid, gid, [callback])</h3>

<p>Asynchronous lchown(2). No arguments other than a possible exception are given<br />to the completion callback.</p>

<h3>fs.lchownSync(path, uid, gid)</h3>

<p>Synchronous lchown(2).</p>

<h3>fs.chmod(path, mode, [callback])</h3>

<p>Asynchronous chmod(2). No arguments other than a possible exception are given<br />to the completion callback.</p>

<h3>fs.chmodSync(path, mode)</h3>

<p>Synchronous chmod(2).</p>

<h3>fs.fchmod(fd, mode, [callback])</h3>

<p>Asynchronous fchmod(2). No arguments other than a possible exception<br />are given to the completion callback.</p>

<h3>fs.fchmodSync(fd, mode)</h3>

<p>Synchronous fchmod(2).</p>

<h3>fs.lchmod(path, mode, [callback])</h3>

<p>Asynchronous lchmod(2). No arguments other than a possible exception<br />are given to the completion callback.</p>

<h3>fs.lchmodSync(path, mode)</h3>

<p>Synchronous lchmod(2).</p>

<h3>fs.stat(path, [callback])</h3>

<p>Asynchronous stat(2). The callback gets two arguments <code>(err, stats)</code> where<br /><code>stats</code> is a <a href="#fs.Stats">fs.Stats</a> object.  See the <a href="#fs.Stats">fs.Stats</a><br />section below for more information.</p>

<h3>fs.lstat(path, [callback])</h3>

<p>Asynchronous lstat(2). The callback gets two arguments <code>(err, stats)</code> where<br /><code>stats</code> is a <code>fs.Stats</code> object. <code>lstat()</code> is identical to <code>stat()</code>, except that if<br /><code>path</code> is a symbolic link, then the link itself is stat-ed, not the file that it<br />refers to.</p>

<h3>fs.fstat(fd, [callback])</h3>

<p>Asynchronous fstat(2). The callback gets two arguments <code>(err, stats)</code> where<br /><code>stats</code> is a <code>fs.Stats</code> object. <code>fstat()</code> is identical to <code>stat()</code>, except that<br />the file to be stat-ed is specified by the file descriptor <code>fd</code>.</p>

<h3>fs.statSync(path)</h3>

<p>Synchronous stat(2). Returns an instance of <code>fs.Stats</code>.</p>

<h3>fs.lstatSync(path)</h3>

<p>Synchronous lstat(2). Returns an instance of <code>fs.Stats</code>.</p>

<h3>fs.fstatSync(fd)</h3>

<p>Synchronous fstat(2). Returns an instance of <code>fs.Stats</code>.</p>

<h3>fs.link(srcpath, dstpath, [callback])</h3>

<p>Asynchronous link(2). No arguments other than a possible exception are given to<br />the completion callback.</p>

<h3>fs.linkSync(srcpath, dstpath)</h3>

<p>Synchronous link(2).</p>

<h3>fs.symlink(linkdata, path, [callback])</h3>

<p>Asynchronous symlink(2). No arguments other than a possible exception are given<br />to the completion callback.</p>

<h3>fs.symlinkSync(linkdata, path)</h3>

<p>Synchronous symlink(2).</p>

<h3>fs.readlink(path, [callback])</h3>

<p>Asynchronous readlink(2). The callback gets two arguments <code>(err,<br />linkString)</code>.</p>

<h3>fs.readlinkSync(path)</h3>

<p>Synchronous readlink(2). Returns the symbolic link's string value.</p>

<h3>fs.realpath(path, [callback])</h3>

<p>Asynchronous realpath(2).  The callback gets two arguments <code>(err,<br />resolvedPath)</code>.  May use <code>process.cwd</code> to resolve relative paths.</p>

<h3>fs.realpathSync(path)</h3>

<p>Synchronous realpath(2). Returns the resolved path.</p>

<h3>fs.unlink(path, [callback])</h3>

<p>Asynchronous unlink(2). No arguments other than a possible exception are given<br />to the completion callback.</p>

<h3>fs.unlinkSync(path)</h3>

<p>Synchronous unlink(2).</p>

<h3>fs.rmdir(path, [callback])</h3>

<p>Asynchronous rmdir(2). No arguments other than a possible exception are given<br />to the completion callback.</p>

<h3>fs.rmdirSync(path)</h3>

<p>Synchronous rmdir(2).</p>

<h3>fs.mkdir(path, [mode], [callback])</h3>

<p>Asynchronous mkdir(2). No arguments other than a possible exception are given<br />to the completion callback. <code>mode</code> defaults to <code>0777</code>.</p>

<h3>fs.mkdirSync(path, [mode])</h3>

<p>Synchronous mkdir(2).</p>

<h3>fs.readdir(path, [callback])</h3>

<p>Asynchronous readdir(3).  Reads the contents of a directory.<br />The callback gets two arguments <code>(err, files)</code> where <code>files</code> is an array of<br />the names of the files in the directory excluding <code>'.'</code> and <code>'..'</code>.</p>

<h3>fs.readdirSync(path)</h3>

<p>Synchronous readdir(3). Returns an array of filenames excluding <code>'.'</code> and<br /><code>'..'</code>.</p>

<h3>fs.close(fd, [callback])</h3>

<p>Asynchronous close(2).  No arguments other than a possible exception are given<br />to the completion callback.</p>

<h3>fs.closeSync(fd)</h3>

<p>Synchronous close(2).</p>

<h3>fs.open(path, flags, [mode], [callback])</h3>

<p>Asynchronous file open. See open(2). <code>flags</code> can be:</p>

<ul>
<li><p><code>'r'</code> - Open file for reading.<br />An exception occurs if the file does not exist.</p></li>
<li><p><code>'r+'</code> - Open file for reading and writing.<br />An exception occurs if the file does not exist.</p></li>
<li><p><code>'w'</code> - Open file for writing.<br />The file is created (if it does not exist) or truncated (if it exists).</p></li>
<li><p><code>'w+'</code> - Open file for reading and writing.<br />The file is created (if it does not exist) or truncated (if it exists).</p></li>
<li><p><code>'a'</code> - Open file for appending.<br />The file is created if it does not exist.</p></li>
<li><p><code>'a+'</code> - Open file for reading and appending.<br />The file is created if it does not exist.</p></li>
</ul>

<p><code>mode</code> defaults to <code>0666</code>. The callback gets two arguments <code>(err, fd)</code>.</p>

<h3>fs.openSync(path, flags, [mode])</h3>

<p>Synchronous open(2).</p>

<h3>fs.utimes(path, atime, mtime, [callback])</h3>

<h3>fs.utimesSync(path, atime, mtime)</h3>

<p>Change file timestamps of the file referenced by the supplied path.</p>

<h3>fs.futimes(fd, atime, mtime, [callback])</h3>

<h3>fs.futimesSync(fd, atime, mtime)</h3>

<p>Change the file timestamps of a file referenced by the supplied file<br />descriptor.</p>

<h3>fs.fsync(fd, [callback])</h3>

<p>Asynchronous fsync(2). No arguments other than a possible exception are given<br />to the completion callback.</p>

<h3>fs.fsyncSync(fd)</h3>

<p>Synchronous fsync(2).</p>

<h3>fs.write(fd, buffer, offset, length, position, [callback])</h3>

<p>Write <code>buffer</code> to the file specified by <code>fd</code>.</p>

<p><code>offset</code> and <code>length</code> determine the part of the buffer to be written.</p>

<p><code>position</code> refers to the offset from the beginning of the file where this data<br />should be written. If <code>position</code> is <code>null</code>, the data will be written at the<br />current position.<br />See pwrite(2).</p>

<p>The callback will be given three arguments <code>(err, written, buffer)</code> where <code>written</code><br />specifies how many <em>bytes</em> were written from <code>buffer</code>.</p>

<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file<br />without waiting for the callback. For this scenario,<br /><code>fs.createWriteStream</code> is strongly recommended.</p>

<h3>fs.writeSync(fd, buffer, offset, length, position)</h3>

<p>Synchronous version of buffer-based <code>fs.write()</code>. Returns the number of bytes<br />written.</p>

<h3>fs.writeSync(fd, str, position, encoding='utf8')</h3>

<p>Synchronous version of string-based <code>fs.write()</code>. Returns the number of <em>bytes</em><br />written.</p>

<h3>fs.read(fd, buffer, offset, length, position, [callback])</h3>

<p>Read data from the file specified by <code>fd</code>.</p>

<p><code>buffer</code> is the buffer that the data will be written to.</p>

<p><code>offset</code> is offset within the buffer where writing will start.</p>

<p><code>length</code> is an integer specifying the number of bytes to read.</p>

<p><code>position</code> is an integer specifying where to begin reading from in the file.<br />If <code>position</code> is <code>null</code>, data will be read from the current file position.</p>

<p>The callback is given the three arguments, <code>(err, bytesRead, buffer)</code>.</p>

<h3>fs.readSync(fd, buffer, offset, length, position)</h3>

<p>Synchronous version of buffer-based <code>fs.read</code>. Returns the number of<br /><code>bytesRead</code>.</p>

<h3>fs.readSync(fd, length, position, encoding)</h3>

<p>Synchronous version of string-based <code>fs.read</code>. Returns the number of<br /><code>bytesRead</code>.</p>

<h3>fs.readFile(filename, [encoding], [callback])</h3>

<p>Asynchronously reads the entire contents of a file. Example:</p>

<pre><code>fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err;
  console.log(data);
});
</code></pre>

<p>The callback is passed two arguments <code>(err, data)</code>, where <code>data</code> is the<br />contents of the file.</p>

<p>If no encoding is specified, then the raw buffer is returned.</p>

<h3>fs.readFileSync(filename, [encoding])</h3>

<p>Synchronous version of <code>fs.readFile</code>. Returns the contents of the <code>filename</code>.</p>

<p>If <code>encoding</code> is specified then this function returns a string. Otherwise it<br />returns a buffer.</p>

<h3>fs.writeFile(filename, data, encoding='utf8', [callback])</h3>

<p>Asynchronously writes data to a file, replacing the file if it already exists.<br /><code>data</code> can be a string or a buffer. The <code>encoding</code> argument is ignored if<br /><code>data</code> is a buffer.</p>

<p>Example:</p>

<pre><code>fs.writeFile('message.txt', 'Hello Node', function (err) {
  if (err) throw err;
  console.log('It\'s saved!');
});
</code></pre>

<h3>fs.writeFileSync(filename, data, encoding='utf8')</h3>

<p>The synchronous version of <code>fs.writeFile</code>.</p>

<h3>fs.watchFile(filename, [options], listener)</h3>

<p>Watch for changes on <code>filename</code>. The callback <code>listener</code> will be called each<br />time the file is accessed.</p>

<p>The second argument is optional. The <code>options</code> if provided should be an object<br />containing two members a boolean, <code>persistent</code>, and <code>interval</code>. <code>persistent</code><br />indicates whether the process should continue to run as long as files are<br />being watched. <code>interval</code> indicates how often the target should be polled,<br />in milliseconds. (On Linux systems with inotify, <code>interval</code> is ignored.) The<br />default is <code>{ persistent: true, interval: 0 }</code>.</p>

<p>The <code>listener</code> gets two arguments the current stat object and the previous<br />stat object:</p>

<pre><code>fs.watchFile('message.text', function (curr, prev) {
  console.log('the current mtime is: ' + curr.mtime);
  console.log('the previous mtime was: ' + prev.mtime);
});
</code></pre>

<p>These stat objects are instances of <code>fs.Stat</code>.</p>

<p>If you want to be notified when the file was modified, not just accessed<br />you need to compare <code>curr.mtime</code> and <code>prev.mtime</code>.</p>

<h3>fs.unwatchFile(filename)</h3>

<p>Stop watching for changes on <code>filename</code>.</p>

<h3>fs.watch(filename, [options], listener)</h3>

<p>Watch for changes on <code>filename</code>, where <code>filename</code> is either a file or a<br />directory.  The returned object is <a href="#fs.FSWatcher">fs.FSWatcher</a>.</p>

<p>The second argument is optional. The <code>options</code> if provided should be an object<br />containing a boolean member <code>persistent</code>, which indicates whether the process<br />should continue to run as long as files are being watched. The default is<br /><code>{ persistent: true }</code>.</p>

<p>The listener callback gets two arguments <code>(event, filename)</code>.  <code>event</code> is either<br />'rename' or 'change', and <code>filename</code> is the name of the file which triggered<br />the event.</p>

<p><strong><em>Warning:</em></strong><br />Providing <code>filename</code> argument in the callback is not supported<br />on every platform (currently it's only supported on Linux and Windows).  Even<br />on supported platforms <code>filename</code> is not always guaranteed to be provided.<br />Therefore, don't assume that <code>filename</code> argument is always provided in the<br />callback, and have some fallback logic if it is null.</p>

<pre><code>fs.watch('somedir', function (event, filename) {
  console.log('event is: ' + event);
  if (filename) {
    console.log('filename provided: ' + filename);
  } else {
    console.log('filename not provided');
  }
});
</code></pre>

<h2>fs.Stats</h2>

<p>Objects returned from <code>fs.stat()</code>, <code>fs.lstat()</code> and <code>fs.fstat()</code> and their<br />synchronous counterparts are of this type.</p>

<ul>
<li><code>stats.isFile()</code></li>
<li><code>stats.isDirectory()</code></li>
<li><code>stats.isBlockDevice()</code></li>
<li><code>stats.isCharacterDevice()</code></li>
<li><code>stats.isSymbolicLink()</code> (only valid with  <code>fs.lstat()</code>)</li>
<li><code>stats.isFIFO()</code></li>
<li><code>stats.isSocket()</code></li>
</ul>

<p>For a regular file <code>util.inspect(stats)</code> would return a string very<br />similar to this:</p>

<pre><code>{ dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT }
</code></pre>

<p>Please note that <code>atime</code>, <code>mtime</code> and <code>ctime</code> are instances<br />of <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> object and to compare the values of<br />these objects you should use appropriate methods. For most<br />general uses <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a> will return<br />the number of milliseconds elapsed since <em>1 January 1970<br />00:00:00 UTC</em> and this integer should be sufficient for<br />any comparison, however there additional methods which can<br />be used for displaying fuzzy information. More details can<br />be found in the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">MDN JavaScript Reference</a> page.</p>

<h2>fs.ReadStream</h2>

<p><code>ReadStream</code> is a <a href="streams.html#readable_Stream">Readable Stream</a>.</p>

<h3>Event: 'open'</h3>

<p><code>function (fd) { }</code></p>

<p><code>fd</code> is the file descriptor used by the ReadStream.</p>

<h3>fs.createReadStream(path, [options])</h3>

<p>Returns a new ReadStream object (See <code>Readable Stream</code>).</p>

<p><code>options</code> is an object with the following defaults:</p>

<pre><code>{ flags: 'r',
  encoding: null,
  fd: null,
  mode: 0666,
  bufferSize: 64 * 1024
}
</code></pre>

<p><code>options</code> can include <code>start</code> and <code>end</code> values to read a range of bytes from<br />the file instead of the entire file.  Both <code>start</code> and <code>end</code> are inclusive and<br />start at 0.</p>

<p>An example to read the last 10 bytes of a file which is 100 bytes long:</p>

<pre><code>fs.createReadStream('sample.txt', {start: 90, end: 99});
</code></pre>

<h2>fs.WriteStream</h2>

<p><code>WriteStream</code> is a <a href="streams.html#writable_Stream">Writable Stream</a>.</p>

<h3>Event: 'open'</h3>

<p><code>function (fd) { }</code></p>

<p><code>fd</code> is the file descriptor used by the WriteStream.</p>

<h3>file.bytesWritten</h3>

<p>The number of bytes written so far. Does not include data that is still queued<br />for writing.</p>

<h3>fs.createWriteStream(path, [options])</h3>

<p>Returns a new WriteStream object (See <code>Writable Stream</code>).</p>

<p><code>options</code> is an object with the following defaults:</p>

<pre><code>{ flags: 'w',
  encoding: null,
  mode: 0666 }
</code></pre>

<p><code>options</code> may also include a <code>start</code> option to allow writing data at<br />some position past the beginning of the file.  Modifying a file rather<br />than replacing it may require a <code>flags</code> mode of <code>r+</code> rather than the<br />default mode <code>w</code>.</p>

<h2>fs.FSWatcher</h2>

<p>Objects returned from <code>fs.watch()</code> are of this type.</p>

<h4>watcher.close()</h4>

<p>Stop watching for changes on the given <code>fs.FSWatcher</code>.</p>

<h4>Event: 'change'</h4>

<p><code>function (event, filename) {}</code></p>

<p>Emitted when something changes in a watched directory or file.<br />See more details in <a href="#fs.watch">fs.watch</a>.</p>

<h4>Event: 'error'</h4>

<p><code>function (exception) {}</code></p>

<p>Emitted when an error occurs.<br /></div></p></div>
</div>
<footer>
    <p>&nbsp;</p>
</footer>
        
<script type="text/javascript" src="../js/sh_main.js"></script>
<script type="text/javascript" src="../js/sh_javascript.min.js"></script>
</div>
    </div>

  </body>
</html>