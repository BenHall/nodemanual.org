<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Node.js Reference Guide</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/sh.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
      }
    </style>
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css"/>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
  <script src="../js/toc.js"></script>
    <script type="text/javascript">
    $(document).ready(function() {
        //$("#toc").accordion({ event: 'mouseover' }, { autoHeight: false });
    });
    </script>
    <link href="../css/style_override.css" rel="stylesheet">
  </head>

  <body>
    <!--
        <div class="topbar">
          <div class="topbar-inner">
            <div class="container-fluid">
              <a class="brand" href="#">Project name</a>
              <ul class="nav">
                <li class="active"><a href="#">Home</a></li>
                <li><a href="#about">About</a></li>
                <li><a href="#contact">Contact</a></li>
              </ul>
              <p class="pull-right">Logged in as <a href="#">username</a></p>
            </div>
          </div>
        </div>
    -->

    <div class="container-fluid">
      <div class="sidebar">
        <div id="toc" class="well">
        <h5>Node.js Reference Guide</h5>
<div>
<ul>
<li><a class="upper" href="synopsis.html">Synopsis</a></li>
<li><a class="upper" href="globals.html">Global Objects</a></li>
<li><a class="upper" href="stdio.html">console</a></li>
<li><a class="upper" href="timers.html">Timers</a></li>
<li><a class="upper" href="modules.html">Modules</a></li>
<li><a class="upper" href="addons.html">Addons</a></li>
<li><a class="upper" href="process.html">process</a></li>
<li><a class="upper" href="util.html">util</a></li>
<li><a class="upper" href="events.html">Events</a></li>
<li><a class="upper" href="buffers.html">Buffers</a></li>
<li><a class="upper" href="streams.html">Streams</a></li>
<li><a class="upper" href="crypto.html">Crypto</a></li>
<li><a class="upper" href="tls.html">TLS (SSL)</a></li>
<li><a class="upper" href="fs.html">File System</a></li>
<li><a class="upper" href="net.html">net</a></li>
<li><a class="upper" href="dgram.html">UDP / Datagram Sockets</a></li>
<li><a class="upper" href="dns.html">DNS</a></li>
<li><a class="upper" href="http.html">HTTP</a></li>
<li><a class="upper" href="https.html">HTTPS</a></li>
<li><a class="upper" href="url.html">URL</a></li>
<li><a class="upper" href="querystring.html">Query String</a></li>
<li><a class="upper" href="readline.html">Readline</a></li>
<li><a class="upper" href="repl.html">REPL</a></li>
<li><a class="upper" href="vm.html">Executing JavaScript</a></li>
<li><a class="upper" href="child_processes.html">Child Processes</a></li>
<li><a class="upper" href="assert.html">Assert</a></li>
<li><a class="upper" href="tty.html">TTY</a></li>
<li><a class="upper" href="zlib.html">Zlib</a></li>
<li><a class="upper" href="os.html">os Module</a></li>
<li><a class="upper" href="debugger.html">Debugger</a></li>
<li><a class="upper" href="cluster.html">Cluster</a></li>
<li><a class="upper" href="appendix_1.html">Appendix 1 - Third Party Modules</a></li>
</ul></div>
</div>
</div>
<div class="content"><p><div class="hero-unit"></p>

<p><a class="hiddenLink" id="http"></a></p>

<h2>HTTP</h2>

<p>To use the HTTP server and client one must <code>require('http')</code>.</p>

<p>The HTTP interfaces in Node are designed to support many features<br />of the protocol which have been traditionally difficult to use.<br />In particular, large, possibly chunk-encoded, messages. The interface is<br />careful to never buffer entire requests or responses--the<br />user is able to stream data.</p>

<p>HTTP message headers are represented by an object like this:</p>

<pre><code>{ 'content-length': '123',
  'content-type': 'text/plain',
  'connection': 'keep-alive',
  'accept': '*/*' }
</code></pre>

<p>Keys are lowercased. Values are not modified.</p>

<p>In order to support the full spectrum of possible HTTP applications, Node's<br />HTTP API is very low-level. It deals with stream handling and message<br />parsing only. It parses a message into headers and body but it does not<br />parse the actual headers or the body.</p>

<h2>http.Server</h2>

<p>This is an <code>EventEmitter</code> with the following events:</p>

<h3>Event: 'request'</h3>

<p><code>function (request, response) { }</code></p>

<p>Emitted each time there is a request. Note that there may be multiple requests<br />per connection (in the case of keep-alive connections).<br /> <code>request</code> is an instance of <code>http.ServerRequest</code> and <code>response</code> is<br /> an instance of <code>http.ServerResponse</code></p>

<h3>Event: 'connection'</h3>

<p><code>function (socket) { }</code></p>

<p>When a new TCP stream is established. <code>socket</code> is an object of type<br /> <code>net.Socket</code>. Usually users will not want to access this event. The<br /> <code>socket</code> can also be accessed at <code>request.connection</code>.</p>

<h3>Event: 'close'</h3>

<p><code>function () { }</code></p>

<p>Emitted when the server closes.</p>

<h3>Event: 'checkContinue'</h3>

<p><code>function (request, response) { }</code></p>

<p>Emitted each time a request with an http Expect: 100-continue is received.<br />If this event isn't listened for, the server will automatically respond<br />with a 100 Continue as appropriate.</p>

<p>Handling this event involves calling <code>response.writeContinue</code> if the client<br />should continue to send the request body, or generating an appropriate HTTP<br />response (e.g., 400 Bad Request) if the client should not continue to send the<br />request body.</p>

<p>Note that when this event is emitted and handled, the <code>request</code> event will<br />not be emitted.</p>

<h3>Event: 'upgrade'</h3>

<p><code>function (request, socket, head) { }</code></p>

<p>Emitted each time a client requests a http upgrade. If this event isn't<br />listened for, then clients requesting an upgrade will have their connections<br />closed.</p>

<ul>
<li><code>request</code> is the arguments for the http request, as it is in the request event.</li>
<li><code>socket</code> is the network socket between the server and client.</li>
<li><code>head</code> is an instance of Buffer, the first packet of the upgraded stream, this may be empty.</li>
</ul>

<p>After this event is emitted, the request's socket will not have a <code>data</code><br />event listener, meaning you will need to bind to it in order to handle data<br />sent to the server on that socket.</p>

<h3>Event: 'clientError'</h3>

<p><code>function (exception) { }</code></p>

<p>If a client connection emits an 'error' event - it will forwarded here.</p>

<h3>http.createServer([requestListener])</h3>

<p>Returns a new web server object.</p>

<p>The <code>requestListener</code> is a function which is automatically<br />added to the <code>'request'</code> event.</p>

<h3>server.listen(port, [hostname], [callback])</h3>

<p>Begin accepting connections on the specified port and hostname.  If the<br />hostname is omitted, the server will accept connections directed to any<br />IPv4 address (<code>INADDR_ANY</code>).</p>

<p>To listen to a unix socket, supply a filename instead of port and hostname.</p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be called<br />when the server has been bound to the port.</p>

<h3>server.listen(path, [callback])</h3>

<p>Start a UNIX socket server listening for connections on the given <code>path</code>.</p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be called<br />when the server has been bound.</p>

<h3>server.close()</h3>

<p>Stops the server from accepting new connections.</p>

<h2>http.ServerRequest</h2>

<p>This object is created internally by a HTTP server -- not by<br />the user -- and passed as the first argument to a <code>'request'</code> listener.</p>

<p>This is an <code>EventEmitter</code> with the following events:</p>

<h3>Event: 'data'</h3>

<p><code>function (chunk) { }</code></p>

<p>Emitted when a piece of the message body is received.</p>

<p>Example: A chunk of the body is given as the single<br />argument. The transfer-encoding has been decoded.  The<br />body chunk is a string.  The body encoding is set with<br /><code>request.setEncoding()</code>.</p>

<h3>Event: 'end'</h3>

<p><code>function () { }</code></p>

<p>Emitted exactly once for each request. After that, no more <code>'data'</code> events<br />will be emitted on the request.</p>

<h3>Event: 'close'</h3>

<p><code>function () { }</code></p>

<p>Indicates that the underlaying connection was terminated before<br /><code>response.end()</code> was called or able to flush.</p>

<p>Just like <code>'end'</code>, this event occurs only once per request, and no more <code>'data'</code><br />events will fire afterwards.</p>

<p>Note: <code>'close'</code> can fire after <code>'end'</code>, but not vice versa.</p>

<h3>request.method</h3>

<p>The request method as a string. Read only. Example:<br /><code>'GET'</code>, <code>'DELETE'</code>.</p>

<h3>request.url</h3>

<p>Request URL string. This contains only the URL that is<br />present in the actual HTTP request. If the request is:</p>

<pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n
</code></pre>

<p>Then <code>request.url</code> will be:</p>

<pre><code>'/status?name=ryan'
</code></pre>

<p>If you would like to parse the URL into its parts, you can use<br /><code>require('url').parse(request.url)</code>.  Example:</p>

<pre><code>node&gt; require('url').parse('/status?name=ryan')
{ href: '/status?name=ryan',
  search: '?name=ryan',
  query: 'name=ryan',
  pathname: '/status' }
</code></pre>

<p>If you would like to extract the params from the query string,<br />you can use the <code>require('querystring').parse</code> function, or pass<br /><code>true</code> as the second argument to <code>require('url').parse</code>.  Example:</p>

<pre><code>node&gt; require('url').parse('/status?name=ryan', true)
{ href: '/status?name=ryan',
  search: '?name=ryan',
  query: { name: 'ryan' },
  pathname: '/status' }
</code></pre>

<h3>request.headers</h3>

<p>Read only.</p>

<h3>request.trailers</h3>

<p>Read only; HTTP trailers (if present). Only populated after the 'end' event.</p>

<h3>request.httpVersion</h3>

<p>The HTTP protocol version as a string. Read only. Examples:<br /><code>'1.1'</code>, <code>'1.0'</code>.<br />Also <code>request.httpVersionMajor</code> is the first integer and<br /><code>request.httpVersionMinor</code> is the second.</p>

<h3>request.setEncoding(encoding=null)</h3>

<p>Set the encoding for the request body. Either <code>'utf8'</code> or <code>'binary'</code>. Defaults<br />to <code>null</code>, which means that the <code>'data'</code> event will emit a <code>Buffer</code> object..</p>

<h3>request.pause()</h3>

<p>Pauses request from emitting events.  Useful to throttle back an upload.</p>

<h3>request.resume()</h3>

<p>Resumes a paused request.</p>

<h3>request.connection</h3>

<p>The <code>net.Socket</code> object associated with the connection.</p>

<p>With HTTPS support, use request.connection.verifyPeer() and<br />request.connection.getPeerCertificate() to obtain the client's<br />authentication details.</p>

<h2>http.ServerResponse</h2>

<p>This object is created internally by a HTTP server--not by the user. It is<br />passed as the second parameter to the <code>'request'</code> event. It is a <code>Writable Stream</code>.</p>

<h3>response.writeContinue()</h3>

<p>Sends a HTTP/1.1 100 Continue message to the client, indicating that<br />the request body should be sent. See the <a href="#event_checkContinue_">checkContinue</a> event on<br /><code>Server</code>.</p>

<h3>response.writeHead(statusCode, [reasonPhrase], [headers])</h3>

<p>Sends a response header to the request. The status code is a 3-digit HTTP<br />status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.<br />Optionally one can give a human-readable <code>reasonPhrase</code> as the second<br />argument.</p>

<p>Example:</p>

<pre><code>var body = 'hello world';
response.writeHead(200, {
  'Content-Length': body.length,
  'Content-Type': 'text/plain' });
</code></pre>

<p>This method must only be called once on a message and it must<br />be called before <code>response.end()</code> is called.</p>

<p>If you call <code>response.write()</code> or <code>response.end()</code> before calling this, the<br />implicit/mutable headers will be calculated and call this function for you.</p>

<p>Note: that Content-Length is given in bytes not characters. The above example<br />works because the string <code>'hello world'</code> contains only single byte characters.<br />If the body contains higher coded characters then <code>Buffer.byteLength()</code><br />should be used to determine the number of bytes in a given encoding.<br />And Node does not check whether Content-Length and the length of the body<br />which has been transmitted are equal or not.</p>

<h3>response.statusCode</h3>

<p>When using implicit headers (not calling <code>response.writeHead()</code> explicitly), this property<br />controls the status code that will be send to the client when the headers get<br />flushed.</p>

<p>Example:</p>

<pre><code>response.statusCode = 404;
</code></pre>

<p>After response header was sent to the client, this property indicates the<br />status code which was sent out.</p>

<h3>response.setHeader(name, value)</h3>

<p>Sets a single header value for implicit headers.  If this header already exists<br />in the to-be-sent headers, its value will be replaced.  Use an array of strings<br />here if you need to send multiple headers with the same name.</p>

<p>Example:</p>

<pre><code>response.setHeader("Content-Type", "text/html");
</code></pre>

<p>or</p>

<pre><code>response.setHeader("Set-Cookie", ["type=ninja", "language=javascript"]);
</code></pre>

<h3>response.getHeader(name)</h3>

<p>Reads out a header that's already been queued but not sent to the client.  Note<br />that the name is case insensitive.  This can only be called before headers get<br />implicitly flushed.</p>

<p>Example:</p>

<pre><code>var contentType = response.getHeader('content-type');
</code></pre>

<h3>response.removeHeader(name)</h3>

<p>Removes a header that's queued for implicit sending.</p>

<p>Example:</p>

<pre><code>response.removeHeader("Content-Encoding");
</code></pre>

<h3>response.write(chunk, encoding='utf8')</h3>

<p>If this method is called and <code>response.writeHead()</code> has not been called, it will<br />switch to implicit header mode and flush the implicit headers.</p>

<p>This sends a chunk of the response body. This method may<br />be called multiple times to provide successive parts of the body.</p>

<p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,<br />the second parameter specifies how to encode it into a byte stream.<br />By default the <code>encoding</code> is <code>'utf8'</code>.</p>

<p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with<br />higher-level multi-part body encodings that may be used.</p>

<p>The first time <code>response.write()</code> is called, it will send the buffered<br />header information and the first body to the client. The second time<br /><code>response.write()</code> is called, Node assumes you're going to be streaming<br />data, and sends that separately. That is, the response is buffered up to the<br />first chunk of body.</p>

<h3>response.addTrailers(headers)</h3>

<p>This method adds HTTP trailing headers (a header but at the end of the<br />message) to the response.</p>

<p>Trailers will <strong>only</strong> be emitted if chunked encoding is used for the<br />response; if it is not (e.g., if the request was HTTP/1.0), they will<br />be silently discarded.</p>

<p>Note that HTTP requires the <code>Trailer</code> header to be sent if you intend to<br />emit trailers, with a list of the header fields in its value. E.g.,</p>

<pre><code>response.writeHead(200, { 'Content-Type': 'text/plain',
                          'Trailer': 'Content-MD5' });
response.write(fileData);
response.addTrailers({'Content-MD5': "7895bf4b8828b55ceaf47747b4bca667"});
response.end();
</code></pre>

<h3>response.end([data], [encoding])</h3>

<p>This method signals to the server that all of the response headers and body<br />has been sent; that server should consider this message complete.<br />The method, <code>response.end()</code>, MUST be called on each<br />response.</p>

<p>If <code>data</code> is specified, it is equivalent to calling <code>response.write(data, encoding)</code><br />followed by <code>response.end()</code>.</p>

<h2>http.request(options, callback)</h2>

<p>Node maintains several connections per server to make HTTP requests.<br />This function allows one to transparently issue requests.  <code>options</code> align<br />with <a href="url.html#url.parse">url.parse()</a>.</p>

<p>Options:</p>

<ul>
<li><code>host</code>: A domain name or IP address of the server to issue the request to.
Defaults to <code>'localhost'</code>.</li>
<li><code>hostname</code>: To support <code>url.parse()</code> <code>hostname</code> is prefered over <code>host</code></li>
<li><code>port</code>: Port of remote server. Defaults to 80.</li>
<li><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath)</li>
<li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>'GET'</code>.</li>
<li><code>path</code>: Request path. Defaults to <code>'/'</code>. Should include query string if any.
E.G. <code>'/index.html?page=12'</code></li>
<li><code>headers</code>: An object containing request headers.</li>
<li><code>auth</code>: Basic authentication i.e. <code>'user:password'</code> to compute an
Authorization header.</li>
<li><code>agent</code>: Controls <a href="#http.Agent">Agent</a> behavior. When an Agent is used
request will default to <code>Connection: keep-alive</code>. Possible values:
<ul><li><code>undefined</code> (default): use <a href="#http.globalAgent">global Agent</a> for this host
and port.</li>
<li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>
<li><code>false</code>: opts out of connection pooling with an Agent, defaults request to
<code>Connection: close</code>.</li></ul></li>
</ul>

<p><code>http.request()</code> returns an instance of the <code>http.ClientRequest</code><br />class. The <code>ClientRequest</code> instance is a writable stream. If one needs to<br />upload a file with a POST request, then write to the <code>ClientRequest</code> object.</p>

<p>Example:</p>

<pre><code>var options = {
  host: 'www.google.com',
  port: 80,
  path: '/upload',
  method: 'POST'
};

var req = http.request(options, function(res) {
  console.log('STATUS: ' + res.statusCode);
  console.log('HEADERS: ' + JSON.stringify(res.headers));
  res.setEncoding('utf8');
  res.on('data', function (chunk) {
    console.log('BODY: ' + chunk);
  });
});

req.on('error', function(e) {
  console.log('problem with request: ' + e.message);
});

// write data to request body
req.write('data\n');
req.write('data\n');
req.end();
</code></pre>

<p>Note that in the example <code>req.end()</code> was called. With <code>http.request()</code> one<br />must always call <code>req.end()</code> to signify that you're done with the request -<br />even if there is no data being written to the request body.</p>

<p>If any error is encountered during the request (be that with DNS resolution,<br />TCP level errors, or actual HTTP parse errors) an <code>'error'</code> event is emitted<br />on the returned request object.</p>

<p>There are a few special headers that should be noted.</p>

<ul>
<li><p>Sending a 'Connection: keep-alive' will notify Node that the connection to<br />the server should be persisted until the next request.</p></li>
<li><p>Sending a 'Content-length' header will disable the default chunked encoding.</p></li>
<li><p>Sending an 'Expect' header will immediately send the request headers.<br />Usually, when sending 'Expect: 100-continue', you should both set a timeout<br />and listen for the <code>continue</code> event. See RFC2616 Section 8.2.3 for more<br />information.</p></li>
<li><p>Sending an Authorization header will override useing the <code>auth</code> option<br />to compute basic authentication.</p></li>
</ul>

<h2>http.get(options, callback)</h2>

<p>Since most requests are GET requests without bodies, Node provides this<br />convenience method. The only difference between this method and <code>http.request()</code> is<br />that it sets the method to GET and calls <code>req.end()</code> automatically.</p>

<p>Example:</p>

<pre><code>var options = {
  host: 'www.google.com',
  port: 80,
  path: '/index.html'
};

http.get(options, function(res) {
  console.log("Got response: " + res.statusCode);
}).on('error', function(e) {
  console.log("Got error: " + e.message);
});
</code></pre>

<h2>http.Agent</h2>

<p>In node 0.5.3+ there is a new implementation of the HTTP Agent which is used<br />for pooling sockets used in HTTP client requests.</p>

<p>Previously, a single agent instance help the pool for single host+port. The<br />current implementation now holds sockets for any number of hosts.</p>

<p>The current HTTP Agent also defaults client requests to using<br />Connection:keep-alive. If no pending HTTP requests are waiting on a socket<br />to become free the socket is closed. This means that node's pool has the<br />benefit of keep-alive when under load but still does not require developers<br />to manually close the HTTP clients using keep-alive.</p>

<p>Sockets are removed from the agent's pool when the socket emits either a<br />"close" event or a special "agentRemove" event. This means that if you intend<br />to keep one HTTP request open for a long time and don't want it to stay in the<br />pool you can do something along the lines of:</p>

<pre><code>http.get(options, function(res) {
  // Do stuff
}).on("socket", function (socket) {
  socket.emit("agentRemove");
});
</code></pre>

<p>Alternatively, you could just opt out of pooling entirely using <code>agent:false</code>:</p>

<pre><code>http.get({host:'localhost', port:80, path:'/', agent:false}, function (res) {
  // Do stuff
})
</code></pre>

<h2>http.globalAgent</h2>

<p>Global instance of Agent which is used as the default for all http client requests.</p>

<h3>agent.maxSockets</h3>

<p>By default set to 5. Determines how many concurrent sockets the agent can have <br />open per host.</p>

<h3>agent.sockets</h3>

<p>An object which contains arrays of sockets currently in use by the Agent. Do not <br />modify.</p>

<h3>agent.requests</h3>

<p>An object which contains queues of requests that have not yet been assigned to <br />sockets. Do not modify.</p>

<h2>http.ClientRequest</h2>

<p>This object is created internally and returned from <code>http.request()</code>.  It<br />represents an <em>in-progress</em> request whose header has already been queued.  The<br />header is still mutable using the <code>setHeader(name, value)</code>, <code>getHeader(name)</code>,<br /><code>removeHeader(name)</code> API.  The actual header will be sent along with the first<br />data chunk or when closing the connection.</p>

<p>To get the response, add a listener for <code>'response'</code> to the request object.<br /><code>'response'</code> will be emitted from the request object when the response<br />headers have been received.  The <code>'response'</code> event is executed with one<br />argument which is an instance of <code>http.ClientResponse</code>.</p>

<p>During the <code>'response'</code> event, one can add listeners to the<br />response object; particularly to listen for the <code>'data'</code> event. Note that<br />the <code>'response'</code> event is called before any part of the response body is received,<br />so there is no need to worry about racing to catch the first part of the<br />body. As long as a listener for <code>'data'</code> is added during the <code>'response'</code><br />event, the entire body will be caught.</p>

<pre><code>// Good
request.on('response', function (response) {
  response.on('data', function (chunk) {
    console.log('BODY: ' + chunk);
  });
});

// Bad - misses all or part of the body
request.on('response', function (response) {
  setTimeout(function () {
    response.on('data', function (chunk) {
      console.log('BODY: ' + chunk);
    });
  }, 10);
});
</code></pre>

<p>This is a <code>Writable Stream</code>.<br />Note: Node does not check whether Content-Length and the length of the body<br />which has been transmitted are equal or not.</p>

<p>This is an <code>EventEmitter</code> with the following events:</p>

<h3>Event 'response'</h3>

<p><code>function (response) { }</code></p>

<p>Emitted when a response is received to this request. This event is emitted only once. The<br /><code>response</code> argument will be an instance of <code>http.ClientResponse</code>.</p>

<p>Options:</p>

<ul>
<li><code>host</code>: A domain name or IP address of the server to issue the request to.</li>
<li><code>port</code>: Port of remote server.</li>
<li><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath)</li>
</ul>

<h3>Event: 'socket'</h3>

<p><code>function (socket) { }</code></p>

<p>Emitted after a socket is assigned to this request.</p>

<h3>Event: 'upgrade'</h3>

<p><code>function (response, socket, head) { }</code></p>

<p>Emitted each time a server responds to a request with an upgrade. If this<br />event isn't being listened for, clients receiving an upgrade header will have<br />their connections closed.</p>

<p>A client server pair that show you how to listen for the <code>upgrade</code> event using <code>http.getAgent</code>:</p>

<pre><code>var http = require('http');
var net = require('net');

// Create an HTTP server
var srv = http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('okay');
});
srv.on('upgrade', function(req, socket, upgradeHead) {
  socket.write('HTTP/1.1 101 Web Socket Protocol Handshake\r\n' +
               'Upgrade: WebSocket\r\n' +
               'Connection: Upgrade\r\n' +
               '\r\n\r\n');

  socket.ondata = function(data, start, end) {
    socket.write(data.toString('utf8', start, end), 'utf8'); // echo back
  };
});

// now that server is running
srv.listen(1337, '127.0.0.1', function() {

  // make a request
  var options = {
    port: 1337,
    host: '127.0.0.1',
    headers: {
      'Connection': 'Upgrade',
      'Upgrade': 'websocket'
    }
  };

  var req = http.request(options);
  req.end();

  req.on('upgrade', function(res, socket, upgradeHead) {
    console.log('got upgraded!');
    socket.end();
    process.exit(0);
  });
});
</code></pre>

<h3>Event: 'continue'</h3>

<p><code>function ()</code></p>

<p>Emitted when the server sends a '100 Continue' HTTP response, usually because<br />the request contained 'Expect: 100-continue'. This is an instruction that<br />the client should send the request body.</p>

<h3>request.write(chunk, encoding='utf8')</h3>

<p>Sends a chunk of the body.  By calling this method<br />many times, the user can stream a request body to a<br />server--in that case it is suggested to use the<br /><code>['Transfer-Encoding', 'chunked']</code> header line when<br />creating the request.</p>

<p>The <code>chunk</code> argument should be an array of integers<br />or a string.</p>

<p>The <code>encoding</code> argument is optional and only<br />applies when <code>chunk</code> is a string.</p>

<h3>request.end([data], [encoding])</h3>

<p>Finishes sending the request. If any parts of the body are<br />unsent, it will flush them to the stream. If the request is<br />chunked, this will send the terminating <code>'0\r\n\r\n'</code>.</p>

<p>If <code>data</code> is specified, it is equivalent to calling <code>request.write(data, encoding)</code><br />followed by <code>request.end()</code>.</p>

<h3>request.abort()</h3>

<p>Aborts a request.  (New since v0.3.8.)</p>

<h3>request.setTimeout(timeout, [callback])</h3>

<p>Once a socket is assigned to this request and is connected <br /><a href="net.html#socket.setTimeout">socket.setTimeout(timeout, [callback])</a><br />will be called.</p>

<h3>request.setNoDelay(noDelay=true)</h3>

<p>Once a socket is assigned to this request and is connected <br /><a href="net.html#socket.setNoDelay">socket.setNoDelay(noDelay)</a><br />will be called.</p>

<h3>request.setSocketKeepAlive(enable=false, [initialDelay])</h3>

<p>Once a socket is assigned to this request and is connected <br /><a href="net.html#socket.setKeepAlive">socket.setKeepAlive(enable, [initialDelay])</a><br />will be called.</p>

<h2>http.ClientResponse</h2>

<p>This object is created when making a request with <code>http.request()</code>. It is<br />passed to the <code>'response'</code> event of the request object.</p>

<p>The response implements the <code>Readable Stream</code> interface.</p>

<h3>Event: 'data'</h3>

<p><code>function (chunk) { }</code></p>

<p>Emitted when a piece of the message body is received.</p>

<h3>Event: 'end'</h3>

<p><code>function () { }</code></p>

<p>Emitted exactly once for each message. No arguments. After<br />emitted no other events will be emitted on the response.</p>

<h3>Event: 'close'</h3>

<p><code>function (err) { }</code></p>

<p>Indicates that the underlaying connection was terminated before<br /><code>end</code> event was emitted.<br />See <a href="#http.ServerRequest">http.ServerRequest</a>'s <code>'close'</code> event for more<br />information.</p>

<h3>response.statusCode</h3>

<p>The 3-digit HTTP response status code. E.G. <code>404</code>.</p>

<h3>response.httpVersion</h3>

<p>The HTTP version of the connected-to server. Probably either<br /><code>'1.1'</code> or <code>'1.0'</code>.<br />Also <code>response.httpVersionMajor</code> is the first integer and<br /><code>response.httpVersionMinor</code> is the second.</p>

<h3>response.headers</h3>

<p>The response headers object.</p>

<h3>response.trailers</h3>

<p>The response trailers object. Only populated after the 'end' event.</p>

<h3>response.setEncoding(encoding=null)</h3>

<p>Set the encoding for the response body. Either <code>'utf8'</code>, <code>'ascii'</code>, or <code>'base64'</code>.<br />Defaults to <code>null</code>, which means that the <code>'data'</code> event will emit a <code>Buffer</code> object..</p>

<h3>response.pause()</h3>

<p>Pauses response from emitting events.  Useful to throttle back a download.</p>

<h3>response.resume()</h3>

<p>Resumes a paused response.<br /></div></p></div>
</div>
<footer>
    <p>&nbsp;</p>
</footer>
        
<script type="text/javascript" src="../js/sh_main.js"></script>
<script type="text/javascript" src="../js/sh_javascript.min.js"></script>
</div>
    </div>

  </body>
</html>